% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsl_aggregate.R
\name{tsl_aggregate}
\alias{tsl_aggregate}
\title{Aggregation of Time Series List}
\usage{
tsl_aggregate(tsl = NULL, new_time = NULL, method = mean, ...)
}
\arguments{
\item{tsl}{(required, list) Time series list. Default: NULL}

\item{new_time}{(required, numeric, numeric vector, Date vector, POSIXct vector, or keyword) Definition of the aggregation pattern. The available options are:
\itemize{
\item numeric vector: only for the "numeric" time class, defines the breakpoints for time series aggregation.
\item "Date" or "POSIXct" vector: as above, but for the time classes "Date" and "POSIXct." In any case, the input vector is coerced to the time class of the \code{tsl} argument.
\item numeric: defines fixed time intervals in the units of \code{tsl} for time series aggregation. Used as is when the time class is "numeric", and coerced to integer and interpreted as days for the time classes "Date" and "POSIXct".
\item keyword (see \code{\link[=utils_time_units]{utils_time_units()}}): the common options for the time classes "Date" and "POSIXct" are: "millennia", "centuries", "decades", "years", "quarters", "months", and "weeks". Exclusive keywords for the "POSIXct" time class are: "days", "hours", "minutes", and "seconds". The time class "numeric" accepts keywords coded as scientific numbers, from "1e8" to "1e-8".
}}

\item{method}{(required, function name) Name of a standard or custom function to aggregate numeric vectors. Typical examples are \code{mean}, \code{max},\code{min}, \code{median}, and \code{quantile}. Default: \code{mean}.}

\item{...}{(optional) further arguments for \code{method}.}
}
\value{
time series list
}
\description{
Function to aggregate zoo objects within a time series list.
This function supports progress bars generated by the \code{progressr} package. See examples.

This function also accepts a parallelization setup via \code{\link[future:plan]{future::plan()}}, but it might only be worth it for large time series lists.

\strong{Objective}

Time series aggregation involves grouping observations and summarizing group values with a statistical function. This operation is useful to:
\itemize{
\item Decrease (downsampling) the temporal resolution of a time series.
\item Highlight particular states of a time series over time. For example, a daily temperature series can be aggregated by month using \code{max} to represent the highest temperatures each month.
\item Transform irregular time series into regular.
}

This function aggregates time series lists \strong{with overlapping times}. Please check such overlap by assessing the columns "begin" and "end " of the data frame resulting from \code{df <- tsl_time(tsl = tsl)}. Aggregation will be limited by the shortest time series in your time series list. To aggregate non-overlapping time series, please subset the individual components of \code{tsl} one by one either using \code{\link[=tsl_subset]{tsl_subset()}} or the syntax \code{tsl = my_tsl[[i]]}.

\strong{Methods}

Any function returning a single number from a numeric vector can be used to aggregate a time series list. Quoted and unquoted function names can be used. Additional arguments to these functions can be passed via the argument \code{...}. Typical examples are:

\itemize{
\item \code{mean} or \code{"mean"}: see \code{\link[=mean]{mean()}}.
\item \code{median} or \code{"median"}: see \code{\link[stats:median]{stats::median()}}.
\item \code{quantile} or "quantile": see \code{\link[stats:quantile]{stats::quantile()}}.
\item \code{min} or \code{"min"}: see \code{\link[=min]{min()}}.
\item \code{max} or \code{"max"}: see \code{\link[=max]{max()}}.
\item \code{sd} or \code{"sd"}: to compute standard deviation, see \code{\link[stats:sd]{stats::sd()}}.
\item \code{var} or \code{"var"}: to compute the group variance, see \code{\link[stats:cor]{stats::var()}}.
\item \code{length} or \code{"length"}: to compute group length.
\item \code{sum} or \code{"sum"}: see \code{\link[=sum]{sum()}}.
\item \code{f_slope} or \code{"f_slope"}: to compute the group slope, see \code{\link[=f_slope]{f_slope()}}.
}
}
\examples{
#parallelization setup (not worth it for this data size)
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableWorkers() - 1
)

#progress bar
if(interactive()){
  progressr::handlers(global = TRUE)
}

# daily aggregation
#----------------------------------

#flight paths of five albatrosses
#scaled to improve visualization
tsl <- tsl_initialize(
  x = albatross,
  id_column = "id",
  time_column = "time"
) |>
  tsl_transform(
    f = f_scale
  )

#plot time series
if(interactive()){
  tsl_plot(
    tsl = tsl,
    guide_columns = 4
    )
}

#check time features
tsl_time(tsl)
#many observations per day
#different starting and ending dates

#aggregation: mean daily values
tsl_daily <- tsl_aggregate(
  tsl = tsl,
  new_time = "days",
  method = mean
)

#check time features
tsl_time(tsl_daily)
#one observation per day
#same starting and ending dates

if(interactive()){
  tsl_plot(
    tsl = tsl_daily,
    guide_columns = 4
  )
}


# other supported keywords
#----------------------------------

#simulate full range of calendar dates
tsl <- tsl_simulate(
  n = 2,
  rows = 1000,
  time_range = c(
    "0000-01-01",
    as.character(Sys.Date())
    )
)

#mean value by millennia (extreme case!!!)
tsl_millennia <- tsl_aggregate(
  tsl = tsl,
  new_time = "millennia",
  method = mean
)

if(interactive()){
  tsl_plot(tsl_millennia)
}

#max value by centuries
tsl_centuries <- tsl_aggregate(
  tsl = tsl,
  new_time = "centuries",
  method = max
)

if(interactive()){
  tsl_plot(tsl_centuries)
}


#quantile 0.75 value by centuries
tsl_centuries <- tsl_aggregate(
  tsl = tsl,
  new_time = "centuries",
  method = stats::quantile,
  probs = 0.75 #argument of stats::quantile()
)

if(interactive()){
  tsl_plot(tsl_centuries)
}
#disable parallelization
future::plan(
  future::sequential
)
}
\seealso{
\code{\link[=zoo_aggregate]{zoo_aggregate()}}

Other tsl_manipulation: 
\code{\link{tsl_colnames_clean}()},
\code{\link{tsl_colnames_set}()},
\code{\link{tsl_names_clean}()},
\code{\link{tsl_names_set}()},
\code{\link{tsl_resample}()},
\code{\link{tsl_split}()},
\code{\link{tsl_subset}()},
\code{\link{tsl_to_df}()},
\code{\link{tsl_transform}()}
}
\concept{transformations}
\concept{tsl_manipulation}
