% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsl_transform.R
\name{tsl_transform}
\alias{tsl_transform}
\title{Transform Values of a Time Series List}
\usage{
tsl_transform(tsl = NULL, f = NULL, ...)
}
\arguments{
\item{tsl}{(required, list of zoo objects) List of time series. Default: NULL}

\item{f}{(required, transformation function) name of a function taking a matrix as input. Currently, the following options are implemented, but any other function taking a matrix as input (for example, \code{\link[=scale]{scale()}}) should work as well:
\itemize{
\item f_proportion: proportion computed by row.
\item f_percentage: percentage computed by row.
\item f_hellinger: Hellinger transformation computed by row
\item f_center: Centering computed by column using the column mean across all zoo objects within \code{tsl}.
\item f_scale: Centering and scaling using the column mean and standard deviation across all zoo objects within \code{tsl}.
\item f_smooth: Time series smoothing with a user defined rolling window.
\item f_detrend_difference: Differencing detrending of time series via \code{\link[=diff]{diff()}}.
\item f_detrend_linear: Detrending of seasonal time series via linear modeling.
\item f_detrend_gam: Detrending of seasonal time series via Generalized Additive Models.
}}

\item{...}{(optional, additional arguments of \code{f}) Optional arguments for the transformation function.}
}
\value{
time series list
}
\description{
Transforms values of the zoo objects within a time series list. Generally, functions introduced via the argument \code{f} should not change the dimensions of the output time series list. However, there are glaring exceptions. For example, \code{\link[=f_center]{f_center()}} and \code{\link[=f_scale]{f_scale()}} compute the overall mean and standard deviation across all zoo objects in the time series list to apply a common transformation. This requires removing exclusive columns from the zoo objects via \code{\link[=tsl_remove_exclusive_cols]{tsl_remove_exclusive_cols()}}.
}
\examples{
#three time series
#climate and ndvi in Fagus sylvatica
#in Spain, Germany, and Sweden
data("fagus_dynamics")

tsl <- tsl_initialize(
  x = fagus_dynamics,
  id_column = "site",
  time_column = "date"
)

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}


#list of transformation functions
#-----------------------------------------
f_list()

#centering with f_center
#-----------------------------------------
#centering based on mean of each variable
#across all time series
tsl_center <- tsl_transform(
  tsl = tsl,
  f = f_center
)

if(interactive()){
  tsl_plot(
    tsl = tsl_center,
    guide_columns = 3
  )
}


#centering and scaling
#-----------------------------------------
#same mean and standard deviation are used to scale each variable across all time series
tsl_scale <- tsl_transform(
  tsl = tsl,
  f = f_scale
)

if(interactive()){
  tsl_plot(
    tsl = tsl_scale,
    guide_columns = 3
  )
}

#also, with scale()
#centers and scales each variable independently of the others
#offers very similar results as f_scale for this case, but it might not work as well for other datasets
tsl_scale <- tsl_transform(
  tsl = tsl,
  f = scale,
  center = TRUE,
  scale = TRUE
)


#moving window smoothing
#-----------------------------------------
#default values
tsl_smooth_mean <- tsl_transform(
  tsl = tsl,
  f = f_smooth_window,
  smoothing_window = 3, #default
  smoothing_f = mean #default
)

if(interactive()){
  tsl_plot(
    tsl = tsl_smooth_mean,
    guide_columns = 3
  )
}

#different smoothing window and function
tsl_smooth_max <- tsl_transform(
  tsl = tsl,
  f = f_smooth_window,
  smoothing_window = 5,
  smoothing_f = max
)

if(interactive()){
  tsl_plot(
    tsl = tsl_smooth_max,
    guide_columns = 3
  )
}

#principal components
#-----------------------------------------
#replaces original variables with their principal components
#requires centering and/or scaling
tsl_pca <- tsl |> tsl_transform(
  f = f_scale
) |>
  tsl_transform(
    f = f_pca
  )

#returns principal components
tsl_colnames(tsl = tsl_pca)

if(interactive()){
  tsl_plot(
    tsl = tsl_pca,
    guide_columns = 3
  )
}

#detrending
#-----------------------------------------
#monthly temperatures in major cities
data("cities_temperature")

#subset Abidjan (city with higher temperature slope)
tsl <- tsl_initialize(
  x = cities_temperature,
  id_column = "city",
  time_column = "date"
) |> tsl_subset(
  names = "Abidjan"
)

if(interactive()){
  tsl_plot(
    tsl = tsl,
    color = "red4"
  )
}

#LINEAR DETRENDING
tsl_detrend_linear <- tsl_transform(
  tsl = tsl,
  f = f_detrend_linear,
  center = FALSE #to keep temperature scale
)

#show effect of linear detrending
if(interactive()){
  plot(tsl[[1]]$temperature, col = "blue")
  lines(tsl_detrend_linear[[1]]$temperature, col = "red4")
}

#rename to join with the original tsl for plotting
tsl_detrend_linear <- tsl_names_set(
  tsl = tsl_detrend_linear,
  names = "detrend_linear"
  )

#DIFFERENCES DETRENDING with lag 1 (monthly lag)
tsl_detrend_difference_1 <- tsl_transform(
  tsl = tsl,
  lag = 1,
  f = f_detrend_difference,
  center = FALSE
)

#rename to join with the original tsl for plotting
tsl_detrend_difference_1 <- tsl_names_set(
  tsl = tsl_detrend_difference_1,
  names = "difference_lag_1"
)

#DIFFERENCES DETRENDING with lag 12 (yearly lag)
tsl_detrend_difference_12 <- tsl_transform(
  tsl = tsl,
  lag = 12,
  f = f_detrend_difference,
  center = FALSE
)

#rename to join with the original tsl for plotting
tsl_detrend_difference_12 <- tsl_names_set(
  tsl = tsl_detrend_difference_12,
  names = "difference_lag_12"
)

#join original data and detrended versions
tsl <- c(
  tsl,
  tsl_detrend_linear,
  tsl_detrend_difference_1,
  tsl_detrend_difference_12
)

if(interactive()){
  tsl_plot(
    tsl = tsl,
    color = "red4"
  )
}


#compare original vs detrended data using f_trend_linear()
tsl_linear_trend <- tsl_transform(
  tsl = tsl,
  f = f_trend_linear
)

if(interactive()){
  tsl_plot(
    tsl = tsl_linear_trend,
    color = "red4"
  )
}
}
