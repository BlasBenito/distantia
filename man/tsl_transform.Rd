% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsl_transform.R
\name{tsl_transform}
\alias{tsl_transform}
\title{Transform Values of a Time Series List}
\usage{
tsl_transform(tsl = NULL, f = NULL, ...)
}
\arguments{
\item{tsl}{(required, list) Time series list. Default: NULL}

\item{f}{(required, transformation function) name of a function taking a matrix as input. Currently, the following options are implemented, but any other function taking a matrix as input (for example, \code{\link[=scale]{scale()}}) should work as well:
\itemize{
\item f_proportion: proportion computed by row.
\item f_percentage: percentage computed by row.
\item f_hellinger: Hellinger transformation computed by row
\item f_center: Centering computed by column using the column mean across all zoo objects within \code{tsl}.
\item f_scale: Centering and scaling using the column mean and standard deviation across all zoo objects within \code{tsl}.
\item f_smooth: Time series smoothing with a user defined rolling window.
\item f_detrend_difference: Differencing detrending of time series via \code{\link[=diff]{diff()}}.
\item f_detrend_linear: Detrending of seasonal time series via linear modeling.
\item f_detrend_gam: Detrending of seasonal time series via Generalized Additive Models.
}}

\item{...}{(optional, additional arguments of \code{f}) Optional arguments for the transformation function.}
}
\value{
time series list
}
\description{
This is a custom wrapper for \code{\link[base:lapply]{base::lapply()}} adapted to work with time series list. The objective of this function is data transformation without dimension changes. Generally, functions introduced via the argument \code{f} should not change the dimensions of the output time series list. See \code{\link[=tsl_resample]{tsl_resample()}} and \code{\link[=tsl_aggregate]{tsl_aggregate()}} for transformations requiring changes in time series dimensions.However, there are glaring exceptions. For example, \code{\link[=f_center]{f_center()}} and \code{\link[=f_scale]{f_scale()}} compute the overall mean and standard deviation across all zoo objects in the time series list to apply a common transformation. This operation requires removing exclusive columns from the zoo objects via \code{\link[=tsl_subset]{tsl_subset()}}.

This function supports progress bars generated by the \code{progressr} package. See examples.

This function also accepts a parallelization setup via \code{\link[future:plan]{future::plan()}}, but it might only be worth it for large time series lists.
}
\examples{
#parallelization setup (not worth it for this data size)
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableWorkers() - 1
)

#progress bar
if(interactive()){
  progressr::handlers(global = TRUE)
}

#two time series
tsl <- tsl_initialize(
  x = fagus_dynamics,
  id_column = "site",
  time_column = "date"
) |>
  tsl_subset(
    names = c("Spain", "Sweden"),
    colnames = c("rainfall", "temperature")
  )

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#centering
#-----------------------------------------
#global centering based on
#mean of each variable
#across all time series
tsl_center <- tsl_transform(
  tsl = tsl,
  f = f_center
)

if(interactive()){
  tsl_plot(
    tsl = tsl_center,
    guide_columns = 3
  )
}


#centering and scaling
#-----------------------------------------
#same mean and standard deviation are used to scale each variable across all time series
tsl_scale <- tsl_transform(
  tsl = tsl,
  f = f_scale
)

if(interactive()){
  tsl_plot(
    tsl = tsl_scale,
    guide_columns = 3
  )
}

# #also, with base::scale()
# tsl_scale <- tsl_transform(
#   tsl = tsl,
#   f = base::scale,
#   center = TRUE,
#   scale = TRUE
# )


#rescaling to a new range
#-----------------------------------------

#rescale between -100 and 100
tsl_rescaled <- tsl_transform(
  tsl = tsl,
  f = f_rescale,
  new_min = -100,
  new_max = 100
)

#old range
sapply(X = tsl, FUN = range)

#new range
sapply(X = tsl_rescaled, FUN = range)


#rounding to n digits
#-----------------------------------------

#rounding to zero digits
tsl_round <- tsl_transform(
  tsl = tsl,
  f = round,
  digits = 0
)

#old values
sapply(X = tsl, FUN = range)

#new range
sapply(X = tsl_round, FUN = range)


#moving window smoothing
#-----------------------------------------
tsl_smooth_mean <- tsl_transform(
  tsl = tsl,
  f = f_smooth_window,
  smoothing_window = 3, #default
  smoothing_f = mean #default
)

if(interactive()){
  tsl_plot(
    tsl = tsl_smooth_mean,
    guide_columns = 3
  )
}

#principal components
#-----------------------------------------
#replaces original variables with their principal components
#requires centering and/or scaling
tsl_pca <- tsl |>
  tsl_transform(
    f = f_scale
  ) |>
  tsl_transform(
    f = f_pca
  )

#returns principal components
tsl_colnames_get(tsl = tsl_pca)

if(interactive()){
  tsl_plot(
    tsl = tsl_pca,
    guide_columns = 3
  )
}

#detrending
#-----------------------------------------

#annual temperature of Abidjan
tsl <- tsl_initialize(
  x = cities_temperature,
  id_column = "city",
  time_column = "date"
) |>
  tsl_subset(
    names = "Abidjan"
  )

if(interactive()){
  tsl_plot(
    tsl = tsl,
    color = "red4"
  )
}

#LINEAR DETRENDING
tsl_detrend_linear <- tsl_transform(
  tsl = tsl,
  f = f_detrend_linear,
  center = FALSE #to keep temperature scale
)

#show effect of linear detrending
if(interactive()){
  plot(tsl[[1]]$temperature, col = "blue")
  lines(tsl_detrend_linear[[1]]$temperature, col = "red4")
}

#rename to join with the original tsl for plotting
tsl_detrend_linear <- tsl_names_set(
  tsl = tsl_detrend_linear,
  names = "detrend_linear"
  )

#DIFFERENCES DETRENDING with lag 1 (monthly lag)
tsl_detrend_difference_1 <- tsl_transform(
  tsl = tsl,
  lag = 1,
  f = f_detrend_difference,
  center = FALSE
)

#rename to join with the original tsl for plotting
tsl_detrend_difference_1 <- tsl_names_set(
  tsl = tsl_detrend_difference_1,
  names = "difference_lag_1"
)

#DIFFERENCES DETRENDING with lag 12 (yearly lag)
tsl_detrend_difference_12 <- tsl_transform(
  tsl = tsl,
  lag = 12,
  f = f_detrend_difference,
  center = FALSE
)

#rename to join with the original tsl for plotting
tsl_detrend_difference_12 <- tsl_names_set(
  tsl = tsl_detrend_difference_12,
  names = "difference_lag_12"
)

#join original data and detrended versions
tsl <- c(
  tsl,
  tsl_detrend_linear,
  tsl_detrend_difference_1,
  tsl_detrend_difference_12
)

#validate this new tsl
tsl <- tsl_diagnose(
  tsl = tsl
)

if(interactive()){
  tsl_plot(
    tsl = tsl,
    color = "red4"
  )
}


#compare original vs detrended data using f_trend_linear()
tsl_linear_trend <- tsl_transform(
  tsl = tsl,
  f = f_trend_linear
)

if(interactive()){
  tsl_plot(
    tsl = tsl_linear_trend,
    color = "red4"
  )
}

#numeric transformations
#-----------------------------------------
#pollen counts from 2 interglacials
tsl <- tsl_initialize(
  x = mis,
  id_column = "mis",
  time_column = "sample_order"
) |>
  tsl_subset(
    names = c("MIS_5", "MIS_7")
  )

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#percentages
tsl_percentage <- tsl_transform(
  tsl = tsl,
  f = f_percentage
)

if(interactive()){
  tsl_plot(
    tsl = tsl_percentage
  )
}

#hellinger transformation
tsl_hellinger <- tsl_transform(
  tsl = tsl,
  f = f_hellinger
)

if(interactive()){
  tsl_plot(
    tsl = tsl_hellinger
  )
}

#custom functions
#-----------------------------------------

#multiply by a scalar y
#the custom function must return a zoo object
tsl_new <- tsl_transform(
  tsl = tsl,
  f = function(x, y) x * y,
  y = 100
)

#disable parallelization
future::plan(
  future::sequential
)
}
\seealso{
Other data_processing: 
\code{\link{f_center}()},
\code{\link{f_detrend_difference}()},
\code{\link{f_detrend_linear}()},
\code{\link{f_hellinger}()},
\code{\link{f_list}()},
\code{\link{f_pca}()},
\code{\link{f_percentage}()},
\code{\link{f_proportion}()},
\code{\link{f_rescale}()},
\code{\link{f_scale}()},
\code{\link{f_slope}()},
\code{\link{f_smooth_window}()},
\code{\link{f_trend_linear}()},
\code{\link{tsl_aggregate}()},
\code{\link{tsl_resample}()},
\code{\link{tsl_split}()},
\code{\link{tsl_subset}()},
\code{\link{tsl_to_df}()},
\code{\link{zoo_aggregate}()},
\code{\link{zoo_permute}()},
\code{\link{zoo_resample}()}
}
\concept{data_processing}
