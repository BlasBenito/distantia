% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distantia_dtw_shift.R
\name{distantia_dtw_shift}
\alias{distantia_dtw_shift}
\title{Time Shift Between Time Series}
\usage{
distantia_dtw_shift(tsl = NULL, distance = "euclidean", bandwidth = 1)
}
\arguments{
\item{tsl}{(required, time series list) list of zoo time series. Default: NULL}

\item{distance}{(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns "names" and "abbreviation" of the dataset \link{distances}. Default: "euclidean".}

\item{bandwidth}{(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka \emph{Itakura parallelogram}) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If \code{1} (default), DTW is unconstrained. If \code{0}, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if \code{lock_step = TRUE}. Default: 1.}
}
\value{
data frame
}
\description{
This function computes an approximation to the time-shift between pairs of time series as the absolute time difference between pairs of observations connected by the time warping path. It returns a data frame with the modal, mean, median, minimum, maximum, quantiles 0.25 and 0.75, and standard deviation of the time shift. The modal and the median are the most generally accurate time-shift descriptors.

This function requires scaled and detrended time series. Still, it might yield non-sensical results in case of degenerate warping paths. Plotting dubious results with [distantia_dtw_plot())] is always a good approach to identify these cases.

[distantia_dtw_plot())]: R:distantia_dtw_plot())
}
\examples{
#load two long-term temperature time series
#local scaling to focus in shape rather than values
#polynomial detrending to make them stationary
tsl <- tsl_init(
  x = cities_temperature,
  name = "name",
  time = "time"
) |>
  tsl_subset(
    names = c("London", "Kinshasa")
  ) |>
  tsl_transform(
    f = f_scale_local
  ) |>
  tsl_transform(
    f = f_detrend_poly
  )


if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#compute shifts
df_shift <- distantia_dtw_shift(
  tsl = tsl,
  distance = "euclidean"
)
df_shift

#check alignment
distantia_dtw_plot(
  tsl = tsl
)
}
\seealso{
Other distantia_support: 
\code{\link{distantia_aggregate}()},
\code{\link{distantia_boxplot}()},
\code{\link{distantia_cluster_hclust}()},
\code{\link{distantia_cluster_kmeans}()},
\code{\link{distantia_matrix}()},
\code{\link{distantia_model_frame}()},
\code{\link{distantia_spatial}()},
\code{\link{distantia_stats}()},
\code{\link{utils_block_size}()},
\code{\link{utils_cluster_hclust_optimizer}()},
\code{\link{utils_cluster_kmeans_optimizer}()},
\code{\link{utils_cluster_silhouette}()}
}
\concept{distantia_support}
