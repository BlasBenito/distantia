% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/tsl_initialize.R
\name{tsl_initialize}
\alias{tsl_initialize}
\alias{tsl_init}
\title{Prepare Time Series List}
\usage{
tsl_initialize(
  x = NULL,
  id_column = NULL,
  time_column = NULL,
  lock_step = FALSE,
  quiet = FALSE
)

tsl_init(
  x = NULL,
  id_column = NULL,
  time_column = NULL,
  lock_step = FALSE,
  quiet = FALSE
)
}
\arguments{
\item{x}{(required, list or data frame) Matrix or data frame in long format, list of vectors, list of matrices, or list of zoo objects. Default: NULL.}

\item{id_column}{(optional, column name) Grouping column separating time series. Values in this column are used as time series names. Default: NULL}

\item{time_column}{(optional if \code{lock_step = FALSE}, and required otherwise, character string) Name of the column representing time, if any. Default: NULL.}

\item{lock_step}{(optional, logical) If TRUE, all input sequences are subsetted to their common times according to the values in \code{time_column}.}

\item{quiet}{(optional, logical) If TRUE, all messages are suppressed. Default: FALSE}
}
\value{
A named list of matrices.
}
\description{
Most functions in this package take a \strong{time series list} (or \strong{tsl} for short) as main input. A \code{tsl} is a list of zoo time-series objects (see \code{\link[zoo:zoo]{zoo::zoo()}}). There is not a formal class for \code{tsl} objects, but there are requirements these objects must follow to ensure the stability of the package functionalities (see \code{\link[=tsl_validate]{tsl_validate()}}). These requirements are:
\itemize{
\item There are no NA, Inf, -Inf, or NaN cases in the zoo objects (see \code{\link[=tsl_count_NA]{tsl_count_NA()}} and \code{\link[=tsl_handle_NA]{tsl_handle_NA()}}).
\item All zoo objects must have at least one common column name to allow time series comparison (see \code{\link[=tsl_colnames]{tsl_colnames()}}).
\item All zoo objects have a character attribute "name" identifying the object. This attribute is not part of the zoo class, but the package ensures that this attribute is not lost during data manipulations.
\item Each element of the time series list is named after the zoo object it contains (see \code{\link[=tsl_zoo_names]{tsl_zoo_names()}}, \code{\link[=tsl_names_set]{tsl_names_set()}} and \code{\link[=tsl_names_clean]{tsl_names_clean()}}).
\item The time series list contains two zoo objects or more.
}

The function \code{\link[=tsl_initialize]{tsl_initialize()}} (and its alias \code{\link[=tsl_init]{tsl_init()}}) is designed to convert the following data structures to a time series list:

\itemize{
\item Long data frame: with an ID column to separate time-series, and a time column that can be of the classes "Date", "POSIXct", "integer", or "numeric". The resulting zoo objects and list elements are named after the values in the ID column.
\item Wide data frame: each column is a time series representing the same variable observed at the same time in different places. Each column is converted to a separate zoo object and renamed.
\item List of vectors: an object like \code{list(a = runif(10), b = runif(10))} is converted to a time series list with as many zoo objects as vectors are defined in the original list.
\item List of matrices: a list containing matrices, such as \code{list(a = matrix(runif(30), 10, 3), b = matrix(runif(36), 12, 3))}.
\item List of zoo objects: a list with zoo objects, such as \code{list(a = zoo_simulate(), b = zoo_simulate())}
}
}
\examples{
#long data frame
#---------------------
data("fagus_dynamics")

#id_column is site
#time column is date
#in this case, all time series have the same length, but that's only optional, as irregular time series are fully supported.
str(fagus_dynamics)

#to tsl
#main assumptions:
#each group in id_column is a different time series
#time series can have different lengths
tsl <- tsl_initialize(
  x = fagus_dynamics,
  id_column = "site",
  time_column = "date"
)

#check validity (no messages or errors if valid)
tsl <- tsl_validate(tsl)

#class of contained objects
lapply(X = tsl, FUN = class)

#get names of the list slots
names(x = tsl)

#get names (names of objects in the list)
tsl_zoo_names(tsl = tsl)

#all names
lapply(X = tsl, FUN = \(x) attributes(x)$name)

#plots
if(interactive()){

  #plot tsl
  tsl_plot(tsl)

  #plot single zoo object
  zoo_plot(x = tsl[[1]])

  #plot single zoo object with default plot method
  plot(x = tsl[[1]])

}


#wide data frame
#--------------------
#wide data frame with same variable in different places
df <- data.frame(
  date = fagus_dynamics[fagus_dynamics$site == "Spain", "date"],
  Spain = fagus_dynamics[fagus_dynamics$site == "Spain", "evi"],
  Germany = fagus_dynamics[fagus_dynamics$site == "Germany", "evi"],
  Sweden = fagus_dynamics[fagus_dynamics$site == "Sweden", "evi"]
)

#to tsl
#key assumptions:
#all columns but "date" represent the same variable in different places
#all time series are of the same length
tsl <- tsl_initialize(
  x = df,
  time_column = "date"
  )

#colnames are forced to be the same
tsl_colnames(tsl)

#plot
if(interactive()){
  tsl_plot(tsl)
}


#list of vectors
#---------------------
#create list of vectors
vector_list <- list(
  a = cumsum(stats::rnorm(n = 50)),
  b = cumsum(stats::rnorm(n = 70)),
  c = cumsum(stats::rnorm(n = 20))
)

#to tsl
#key assumptions:
#all vectors represent the same variable in different places
#time series can be of different lengths
#no time column, integer indices are used as time
tsl <- tsl_initialize(
  x = vector_list
)

#plot
if(interactive()){
  tsl_plot(tsl)
}

#list of matrices
#-------------------------
#create list of matrices
matrix_list <- list(
  a = matrix(runif(30), nrow = 10, ncol = 3),
  b = matrix(runif(80), nrow = 20, ncol = 4) #one more column
)

#to tsl
#key assumptions:
#each matrix represents a multivariate time series in a different place
#all multivariate time series have the same columns
#no time column, integer indices are used as time
tsl <- tsl_initialize(
  x = matrix_list
)

#check column names
tsl_colnames(tsl = tsl)

#remove exclusive column
tsl <- tsl_remove_exclusive_cols(tsl = tsl)
tsl_colnames(tsl = tsl)

#plot
if(interactive()){
  tsl_plot(tsl)
}

#list of zoo objects
#-------------------------
zoo_list <- list(
  a = zoo_simulate(),
  b = zoo_simulate()
)

#looks like a time series list! But...
zoo_list <- tsl_validate(tsl = zoo_list)

#let's set the names
zoo_list <- tsl_names_set(tsl = zoo_list)

#check again: it's now a valid time series list
zoo_list <- tsl_validate(tsl = zoo_list)

#to do all this in one go:
tsl <- tsl_initialize(
  x = list(
    a = zoo_simulate(),
    b = zoo_simulate()
  )
)

#plot
if(interactive()){
  tsl_plot(tsl)
}


}
