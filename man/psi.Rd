% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/psi.R
\name{psi}
\alias{psi}
\title{Normalized Dissimilarity Score}
\usage{
psi(path_sum = NULL, auto_sum = NULL, diagonal = TRUE)
}
\arguments{
\item{path_sum}{(required, numeric) Result of \code{\link[=psi_cost_path_sum]{psi_cost_path_sum()}}, the sum of distances of the least cost path between two time series. Default: NULL}

\item{auto_sum}{(required, numeric) Result of \code{\link[=psi_auto_sum]{psi_auto_sum()}}, the cumulative sum of the consecutive cases of two time series. Default: NULL}

\item{diagonal}{(optional, logical) Used to correct the computation of \code{psi} when diagonals are used during the computation of the least cost path. If the cost matrix and least cost path were computed using \code{diagonal = TRUE}, this argument should be \code{TRUE} as well. Default: TRUE}
}
\value{
numeric value
}
\description{
Demonstration function to computes the \code{psi} dissimilarity score (Birks and Gordon 1985). Psi is computed as  \eqn{\psi = (2a - b) / b}, where \eqn{a} is the sum of distances in the least cost path between two time series, and \eqn{b} is the cumulative sum of distances between the consecutive cases of the two time series.

If diagonals are used in the computation of the least cost path, then one is added to the result of the equation above.
}
\examples{
#distance metric
d <- "euclidean"

#use diagonals in least cost computations
diagonal <- TRUE

#remove blocks from least cost path
ignore_blocks <- TRUE

#simulate two time series
tsl <- tsl_simulate(
  n = 2,
  seed = 1
)

if(interactive()){
  tsl_plot(tsl = tsl)
}

#distance matrix
dist_matrix <- psi_dist_matrix(
  x = tsl[[1]],
  y = tsl[[2]],
  distance = d
)

#cost matrix
cost_matrix <- psi_cost_matrix(
  dist_matrix = dist_matrix,
  diagonal = diagonal
)

#least cost path
cost_path <- psi_cost_path(
  dist_matrix = dist_matrix,
  cost_matrix = cost_matrix,
  diagonal = diagonal
)

if(interactive()){
  utils_matrix_plot(
    m = cost_matrix,
    path = cost_path
    )
}

#remove blocks from least cost path
if(ignore_blocks == TRUE){
  cost_path <- psi_cost_path_ignore_blocks(
    path = cost_path
  )
}

#sum of distances in least cost path
xy_distance <- psi_cost_path_sum(
  path = cost_path
  )

#auto sum of both time series
xy_autodistance <- psi_auto_sum(
  x = tsl[[1]],
  y = tsl[[2]],
  path = cost_path,
  distance = d
)

#dissimilarity score
psi(
  path_sum = xy_distance,
  auto_sum = xy_autodistance,
  diagonal = diagonal
)

#full computation in one line
distantia(
  tsl = tsl,
  distance = d,
  diagonal = diagonal,
  ignore_blocks = ignore_blocks
)$psi

if(interactive()){
  distantia_plot(
    tsl = tsl,
    distance = d,
    diagonal = diagonal,
    ignore_blocks = ignore_blocks
  )
}
}
