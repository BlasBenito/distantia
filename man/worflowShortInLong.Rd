% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/worflowShortInLong.R
\name{worflowShortInLong}
\alias{worflowShortInLong}
\title{Finds the section in a long sequence that better matches a short sequence.}
\usage{
workflowPsi(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  min.length = NULL,
  max.length = NULL,
  parallel.execution = TRUE
  )
}
\arguments{
\item{sequences}{dataframe with multiple sequences identified by a grouping column generated by \code{\link{prepareSequences}}.}

\item{grouping.column}{character string, name of the column in \code{sequences} to be used to identify separates sequences within the file.}

\item{time.column}{character string, name of the column with time/depth/rank data.}

\item{exclude.columns}{character string or character vector with column names in \code{sequences} to be excluded from the analysis.}

\item{method}{character string naming a distance metric. Valid entries are: "manhattan", "euclidean", "chi", and "hellinger". Invalid entries will throw an error.}

\item{diagonal}{boolean, if \code{TRUE} (default), diagonals are included in the computation of the least cost path. This is the best option if the user suspects that a given segment in the short sequence might be identical to the short sequence.}

\item{min.length}{integer, minimum length (in rows) of the subsets of the long sequence to be matched against the short sequence. Defaults to 75 percent of the length of the short sequence.}

\item{max.length}{integer, maximum length (in rows) of the subsets of the long sequence to be matched against the short sequence. Defaults to 125 percent of the length of the short sequence.}

\item{parallel.execution}{boolean, if \code{TRUE} (default), execution is parallelized, and serialized if \code{FALSE}.}
}
\value{
A dataframe with three columns:
\itemize{
\item \emph{first.row} first row of the segment in the long sequence matched against the short one.
\item \emph{last.row} last row of the segment in the long sequence matched against the short one.
\item \emph{psi} psi values, ordered from lower (m√°ximum similarity / minimum dissimilarity) to higher.
}
}
\description{
This workflow works under the following scenario: the user has a short sequence, and a long sequence, and has the objective of finding the segment in the long sequence that better matches the short sequence. The size of the segment in the long sequence is either defined by the user through the arguments \code{min.length} and \code{max.length}. If left empty, \code{min.length} equals to a 75 percent of the length of the short sequence, and \code{max.length} equals to a 125 percent of the length of the short sequence. Note that this is a brute force algorithm, and a large difference between both arguments may generate a very large of subsets of the long sequence. The algorithm is parallelized and optimized as possible, so still, large searches are possible.
}
\examples{

\dontrun{

#loading the data
data(sequencesMIS)

#removing grouping column
sequencesMIS$MIS <- NULL

#mock-up short sequence
MIS.short <- sequencesMIS[1:10, ]

#mock-up long sequence
MIS.long <- sequencesMIS[1:30, ]

#preparing sequences
MIS.sequences <- prepareSequences(
 sequence.A = MIS.short,
 sequence.A.name = "short",
 sequence.B = MIS.long,
 sequence.B.name = "long",
 grouping.column = "id",
 transformation = "hellinger"
 )

#matching sequences
#min.length and max.length are
#minimal to speed up execution
MIS.psi <- worflowShortInLong(
 sequences = MIS.sequences,
 grouping.column = "id",
 time.column = NULL,
 exclude.columns = NULL,
 method = "manhattan",
 diagonal = FALSE,
 min.length = nrow(MIS.short) - 1,
 max.length = nrow(MIS.short) + 1,
 parallel.execution = TRUE
 )

#output dataframe
MIS.psi

}

}
\author{
Blas Benito <blasbenito@gmail.com>
}
