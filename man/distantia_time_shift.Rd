% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distantia_time_shift.R
\name{distantia_time_shift}
\alias{distantia_time_shift}
\title{Time Shift Between Time Series}
\usage{
distantia_time_shift(tsl = NULL, distance = "euclidean", bandwidth = 1)
}
\arguments{
\item{tsl}{(required, time series list) list of zoo time series. Default: NULL}

\item{distance}{(optional, character vector) name or abbreviation of the distance method. Valid values are in the columns "names" and "abbreviation" of the dataset \link{distances}. Default: "euclidean".}

\item{bandwidth}{(optional, numeric) Proportion of space at each side of the cost matrix diagonal (aka \emph{Itakura parallelogram}) defining a valid region for dynamic time warping, used to control the flexibility of the warping path. This method prevents degenerate alignments due to differences in magnitude between time series when the data is not properly scaled. If \code{1} (default), DTW is unconstrained. If \code{0}, DTW is fully constrained and the warping path follows the matrix diagonal. Recommended values may vary depending on the nature of the data. Ignored if \code{lock_step = TRUE}. Default: 1.}
}
\value{
data frame
}
\description{
This function computes an approximation to the time-shift between pairs of time series as the absolute time difference between pairs of observations connected by the time warping path. It returns a data frame with the mean, median, minimum, maximum, quantiles 0.25 and 0.75, and standard deviation of the time shift.

This function requires scaled and detrended time series. Still, it might yield non-sensical results.
}
\examples{
#load three time series
tsl <- tsl_init(
  x = cities_temperature,
  name = "name",
  time = "time"
) |>
  tsl_subset(
    names = c("London", "Kinshasa"),
    time = c("2000-01-01", "2010-01-01")
  ) |>
  tsl_transform(
    f = f_scale_local
  )

#the data has a polynomial trend
tsl_trend <- tsl_transform(
  tsl = tsl,
  f = f_trend_poly
)

if(interactive()){
  tsl_plot(
    tsl = tsl_trend
  )
}

#polynomial detrending
tsl <- tsl_transform(
  tsl = tsl,
  f = f_detrend_poly
)

if(interactive()){
  tsl_plot(
    tsl = tsl
  )
}

#compute shifts
df_shift <- distantia_time_shift(
  tsl = tsl,
  distance = "euclidean"
)
df_shift

#check alignment
distantia_plot(
  tsl = tsl[c("Kinshasa", "London")]
)
}
\seealso{
Other dissimilarity_analysis: 
\code{\link{distantia_aggregate}()},
\code{\link{distantia_boxplot}()},
\code{\link{distantia_cluster_hclust}()},
\code{\link{distantia_cluster_kmeans}()},
\code{\link{distantia_matrix}()},
\code{\link{distantia_plot}()},
\code{\link{distantia_spatial_network}()},
\code{\link{distantia_stats}()},
\code{\link{momentum_boxplot}()},
\code{\link{momentum_stats}()},
\code{\link{momentum_to_wide}()}
}
\concept{dissimilarity_analysis}
