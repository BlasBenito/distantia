% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distantia_cluster_hclust.R
\name{distantia_cluster_hclust}
\alias{distantia_cluster_hclust}
\title{Hierarchical Clustering of Time Series}
\usage{
distantia_cluster_hclust(df = NULL, clusters = NULL, method = "complete")
}
\arguments{
\item{df}{(required, data frame) Output of \code{\link[=distantia]{distantia()}}. Default: NULL}

\item{clusters}{(required, integer) Number of groups to generate. If NULL (default), \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}} optimizes the number of clusters. Default: NULL}

\item{method}{(optional, character string) Argument of \code{\link[stats:hclust]{stats::hclust()}} defining the agglomerative method. One of: "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC). Unambiguous abbreviations are accepted as well. If NULL (default), \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}} finds the optimal method. Default: "complete".}
}
\value{
List with the following objects:
\itemize{
\item \code{hclust}: hclust object.
\item \code{clusters}: integer, number of clusters.
\item \code{silhouette_width}: mean silhouette width of the hierarchical clustering.
\item \code{df}: data frame with names of the time series, their group assignation, and their silhouette width scores.
\item \code{d}: psi distance matrix.
\item \code{optimization}: only if \code{clusters = NULL}, data frame with optimization results from \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}}.
}
}
\description{
This function combines the dissimilarity scores computed by \code{\link[=distantia]{distantia()}}, the agglomerative clustering methods provided by \code{\link[stats:hclust]{stats::hclust()}}, and the clustering optimization method implemented in \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}} to help group together time series with similar features. The optimization method uses a parallelized grid search to find the combination of number of clusters and agglomerative method (optional) maximizing the overall silhouette score of the solution (see \code{\link[=cluster_silhouette]{cluster_silhouette()}}).
}
\details{
All relevant details about clustering methods and relevant references are available in the help file of \code{\link[stats:hclust]{stats::hclust()}}.
}
\examples{
#daily covid prevalence in California counties
data("covid_prevalence")

#load as tsl and aggregate to monthly data to accelerate example execution
tsl <- tsl_initialize(
  x = covid_prevalence,
  id_column = "county",
  time_column = "date"
) |>
  tsl_aggregate(
    new_time = "months",
    fun = sum
  )

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl[1:3],
    guide_columns = 3
    )
}

#dissimilarity analysis
distantia_df <- distantia(
  tsl = tsl
)

#hierarchical clustering with a given number of clusters
#-------------------------------------------------------
distantia_clust <- distantia_cluster_hclust(
  df = distantia_df,
  clusters = 5, #arbitrary number!
  method = "complete"
)

#names of the output object
names(distantia_clust)

#distance matrix used for clustering
distantia_clust$d

#number of clusters
distantia_clust$clusters

#clustering data frame
#group assignation in column "cluster"
#negatives in column "silhouette_width" higlight anomalous cluster assignation
distantia_clust$df

#mean silhouette width of the clustering solution

distantia_clust$silhouette_width

#plot
if(interactive()){

  clust <- distantia_clust$hclust
  k <- distantia_clust$clusters

  #tree plot
  plot(
    x = clust,
    hang = -1
    )

  #highlight groups
  stats::rect.hclust(
    tree = clust,
    k = k,
    cluster = stats::cutree(
      tree = clust,
      k = k
    )
  )

}


#optimized hierarchical clustering
#---------------------------------

#for large datasets, parallelization accelerates cluster optimization
future::plan(
 future::multisession,
 workers = 2 #set to parallelly::availableWorkers() - 1
)

#progress bar
progressr::handlers(global = TRUE)

#auto-optimization of clusters and method
distantia_clust <- distantia_cluster_hclust(
  df = distantia_df,
  clusters = NULL,
  method = NULL
)

#names of the output object
#a new object named "optimization" should appear
names(distantia_clust)

#first rows of the optimization data frame
#optimized clustering in first row
head(distantia_clust$optimization)

#plot
if(interactive()){

  clust <- distantia_clust$hclust
  k <- distantia_clust$clusters

  #tree plot
  plot(
    x = clust,
    hang = -1
  )

  #highlight groups
  stats::rect.hclust(
    tree = clust,
    k = k,
    cluster = stats::cutree(
      tree = clust,
      k = k
    )
  )

}

#disable parallelization
future::plan(
  future::sequential
)
}
\seealso{
\code{\link[stats:kmeans]{stats::kmeans()}}
}
