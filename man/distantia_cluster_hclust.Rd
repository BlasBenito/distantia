% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distantia_cluster_hclust.R
\name{distantia_cluster_hclust}
\alias{distantia_cluster_hclust}
\title{Hierarchical Clustering of a Distantia Data Frame}
\usage{
distantia_cluster_hclust(df = NULL, clusters = NULL, method = "complete")
}
\arguments{
\item{df}{(required, data frame) Output of \code{\link[=distantia]{distantia()}}. Default: NULL}

\item{clusters}{(required, integer) Number of groups to generate. If NULL (default), \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}} is used to find the number of clusters that maximizes the mean silhouette width (see \code{\link[=cluster_silhouette]{cluster_silhouette()}}). Default: NULL}

\item{method}{(optional, character string) The agglomeration method to be used. This should be (an unambiguous abbreviation of) one of "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC). Default: "complete".}
}
\value{
List with the following objects:
\itemize{
\item \code{hclust}: hclust object.
\item \code{clusters}: integer, number of clusters.
\item \code{silhouette_width}: mean silhouette width of the hierarchical clustering.
\item \code{df}: data frame with names of the time series, their group assignation, and their silhouette width scores.
\item \code{d}: psi distance matrix.
\item \code{optimization}: only if \code{clusters = NULL}, data frame with optimization results from \code{\link[=cluster_hclust_optimizer]{cluster_hclust_optimizer()}}.
}
}
\description{
Hierarchical Clustering of a Distantia Data Frame
}
\details{
All relevant details about clustering methods and relevant references are available in the help file of \code{\link[stats:hclust]{stats::hclust()}}.
}
\examples{

tsl <- tsl_simulate(
  n = 10,
  time_range = c(
    "2010-01-01 12:00:25",
    "2024-12-31 11:15:45"
  )
)

df <- distantia(
  tsl = tsl
)

hc <- distantia_cluster_hclust(
  df = df
)

hc$df

plot(
  x = hc$hclust,
  hang = -1
  )

stats::rect.hclust(
  tree = hc$hclust,
  k = hc$clusters,
  border = grDevices::hcl.colors(
    n = hc$clusters,
    palette = "Zissou 1"
    )
  )

}
\seealso{
\code{\link[stats:kmeans]{stats::kmeans()}}
}
