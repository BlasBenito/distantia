% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/distanceMatrix.R
\name{distanceMatrix}
\alias{distanceMatrix}
\title{Distance Matrix Between Multivariate Time Series.}
\usage{
distanceMatrix(
  sequences = NULL,
  grouping.column = NULL,
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  parallel.execution = TRUE
)
}
\arguments{
\item{sequences}{(required, data frame) dataframe with multiple sequences identified by a grouping column. Generally the ouput of [prepareSequences()]. Default: NULL}

\item{grouping.column}{(required, character string) name of the column in `sequences` grouping separate time series. This argument is ignored if `sequence.A` and `sequence.B` are provided. Default: NULL}

\item{time.column}{(required, character string) name of the column with time/depth/rank data. Default: NULL}

\item{exclude.columns}{(optional, character vector) names of columns to be excluded from the distance computation. Default: NULL}

\item{method}{(optional, character string) name of the distance metric. Valid entries are: "manhattan", "euclidean", "chi", and "hellinger". Default: "manhattan}

\item{parallel.execution}{(optional, logical) if `TRUE`, execution is parallelized. Default: `FALSE`}
}
\value{
A list with named slots containing the the distance matrices of every possible combination of sequences according to \code{grouping.column}.
}
\description{
Computes distance matrices among the samples of two or more multivariate time-series provided in a single dataframe (generally produced by [prepareSequences](), identified by a grouping column (argument `grouping.column`). Distances can be computed with the methods "manhattan", "euclidean", "chi", and "hellinger", and are implemented in the function [distance].

The function uses the packages \code{\link[parallel]{parallel}}, \code{\link[foreach]{foreach}}, and \code{\link[doParallel]{doParallel}} to compute distances matrices among different sequences in parallel. It is configured to use all processors available minus one.
}
\details{
Distances are computed as:
\itemize{
\item "manhattan": `sum(abs(x - y))`
\item "euclidean": `qrt(sum((x - y)^2))`.
\item "chi":
    `xy <- x + y`
    `y. <- y / sum(y)`
    `x. <- x / sum(x)`
    `sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))`
\item "hellinger": `sqrt(1/2 * sum((sqrt(x) - sqrt(y))^2))`
}
}
\examples{

#loading data
data(sequenceA)
data(sequenceB)

#preparing datasets
AB.sequences <- prepareSequences(
 sequence.A = sequenceA,
 sequence.A.name = "A",
 sequence.B = sequenceB,
 sequence.B.name = "B",
 merge.mode = "complete",
 if.empty.cases = "zero",
 transformation = "hellinger"
 )

#computing distance matrix
AB.distance.matrix <- distanceMatrix(
 sequences = AB.sequences,
 grouping.column = "id",
 method = "manhattan",
 parallel.execution = FALSE
 )


#plot
if(interactive()){
 plotMatrix(distance.matrix = AB.distance.matrix)
}


}
\seealso{
\code{\link{distance}}
}
\author{
Blas Benito <blasbenito@gmail.com>
}
