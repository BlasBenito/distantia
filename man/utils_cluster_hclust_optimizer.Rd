% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/utils_cluster_hclust_optimizer.R
\name{utils_cluster_hclust_optimizer}
\alias{utils_cluster_hclust_optimizer}
\title{Optimal Number of Clusters for Hierarchical Clustering}
\usage{
utils_cluster_hclust_optimizer(d = NULL, method = NULL)
}
\arguments{
\item{d}{(required, matrix) distance matrix typically resulting from \code{\link[=distantia_matrix]{distantia_matrix()}}, but any other square matrix should work. Default: NULL}

\item{method}{(optional, character string) Argument of \code{\link[stats:hclust]{stats::hclust()}} defining the agglomerative method. One of: "ward.D", "ward.D2", "single", "complete", "average" (= UPGMA), "mcquitty" (= WPGMA), "median" (= WPGMC) or "centroid" (= UPGMC). Unambiguous abbreviations are accepted as well.}
}
\value{
data frame
}
\description{
Performs a parallelized grid search to find the number of clusters maximizing the overall silhouette width of the clustering solution (see \code{\link[=utils_cluster_silhouette]{utils_cluster_silhouette()}}). When \code{method = NULL}, the optimization also includes all methods available in \code{\link[stats:hclust]{stats::hclust()}} in the grid search. This function supports parallelization via \code{\link[future:plan]{future::plan()}} and a progress bar generated by the \code{progressr} package (see Examples).
}
\examples{
#parallelization and progress bar
#for large datasets, parallelization accelerates cluster optimization
future::plan(
  future::multisession,
  workers = 2 #set to parallelly::availableWorkers() - 1
)

#progress bar
if(interactive()){
  progressr::handlers(global = TRUE)
}

#daily covid prevalence
#in 10 California counties
#aggregated by month
tsl <- tsl_initialize(
  x = covid_prevalence,
  id_column = "county",
  time_column = "date"
) |>
  tsl_subset(
    names = 1:10
  ) |>
  tsl_aggregate(
    new_time = "months",
    fun = sum
  )

if(interactive()){
  #plotting first three time series
  tsl_plot(
    tsl = tsl_subset(
      tsl = tsl,
      names = 1:3
    ),
    guide_columns = 3
  )
}

#compute dissimilarity matrix
psi_matrix <- distantia(
  tsl = tsl,
  lock_step = TRUE
) |>
  distantia_matrix()

#optimize hierarchical clustering
hclust_optimization <- utils_cluster_hclust_optimizer(
  d = psi_matrix
)

#best solution in first row
head(hclust_optimization)

#disable parallelization
future::plan(
  future::sequential
)
}
\seealso{
Other internal: 
\code{\link{distantia-package}},
\code{\link{utils_block_size}()},
\code{\link{utils_check_distantia_args}()},
\code{\link{utils_check_list_class}()},
\code{\link{utils_clean_names}()},
\code{\link{utils_cluster_kmeans_optimizer}()},
\code{\link{utils_cluster_silhouette}()},
\code{\link{utils_coerce_time_class}()},
\code{\link{utils_color_breaks}()},
\code{\link{utils_color_continuous_default}()},
\code{\link{utils_color_discrete_default}()},
\code{\link{utils_df_to_matrix}()},
\code{\link{utils_digits}()},
\code{\link{utils_distantia_df_split}()},
\code{\link{utils_global_scaling_params}()},
\code{\link{utils_importance_df_to_wide}()},
\code{\link{utils_is_time}()},
\code{\link{utils_line_color}()},
\code{\link{utils_line_guide}()},
\code{\link{utils_matrix_guide}()},
\code{\link{utils_matrix_plot}()},
\code{\link{utils_new_time}()},
\code{\link{utils_optimize_loess}()},
\code{\link{utils_optimize_spline}()},
\code{\link{utils_prepare_df}()},
\code{\link{utils_prepare_matrix_list}()},
\code{\link{utils_prepare_time}()},
\code{\link{utils_prepare_vector_list}()},
\code{\link{utils_prepare_zoo_list}()},
\code{\link{utils_rescale_vector}()},
\code{\link{utils_time_keywords}()},
\code{\link{utils_time_keywords_dictionary}()},
\code{\link{utils_time_keywords_translate}()},
\code{\link{utils_time_units}()},
\code{\link{utils_tsl_pairs}()}
}
\concept{internal}
