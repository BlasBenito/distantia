---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)
```
# distantia

<!-- badges: start -->
<!-- badges: end -->

The package **distantia** implements the *sequence slotting* method proposed described in ["Numerical methods in Quaternary pollen analysis"](https://onlinelibrary.wiley.com/doi/abs/10.1002/gea.3340010406) (Birks and Gordon, 1985). In this document I briefly explain the logics behind the method, and the extensions and new applications implementd in the **distantia** package

## Installation

You can install the released version of distantia from [CRAN](https://CRAN.R-project.org) with:

```{r, eval=FALSE}
install.packages("distantia")
```

And the development version from [GitHub](https://github.com/) with:

```{r, eval=FALSE}
# install.packages("devtools")
devtools::install_github("BlasBenito/distantia")
```

Loading the library, plus other helper libraries:

```{r, message=FALSE, warning=FALSE, error=FALSE, eval=FALSE}
library(distantia)
library(kableExtra)
```


## Logics behind the method

The objective of this method is to **compute the dissimilarity between two (or more) multivariate time-series** (hereafter, *sequences*). These sequences can be either regular (same time between consecutive samples) or irregular (different time between consecutive samples), and can be aligned (same number of samples) or unaligned (different number of samples). 

The only restrictions are that any given entity represented by a column must have the same name in both datasets, and that these sequences must be ordered (in time, depth, rank) from top to bottom in the given dataframe.

The package provides two example datasets based on the Abernethy pollen core (Birks and Mathewes (1978):

```{r, eval=FALSE}
data(sequenceA)
data(sequenceB)

str(sequenceA)
str(sequenceB)

kable(sequenceA, caption = "Sequence A")
kable(sequenceB, caption = "Sequence B")
```

The function **prepareSequences** gets them ready for analysis by matching colum names and handling empty data, as follows:

```{r, eval=FALSE}
help(prepareSequences)

AB.sequences <- prepareSequences(
  sequence.A = sequenceA,
  sequence.A.name = "A",
  sequence.B = sequenceB,
  sequence.B.name = "B",
  merge.mode = "complete",
  if.empty.cases = "zero",
  transformation = "hellinger"
)

str(AB.sequences)
```

The function allows to merge two multivariate time-series into a single table ready for the computation of dissimilarity between sequences.

### Computation of dissimilarity

The computation of dissimlarity between two sequences goes as follows:

**1.** Computation of a **distance matrix** among the samples of both sequences.

```{r, fig.width = 7, fig.height = 4, eval=FALSE}

#computing distance matrix
AB.distance.matrix <- distanceMatrix(
  sequences = AB.sequences,
  method = "manhattan"
)

#plotting distance matrix
plotMatrix(distance.matrix = AB.distance.matrix)
```

**2.** Computation of the least cost matrix. The value of the upper-right cell in the plotted matrix (actually, the lower-right cell in the actual data matrix, the matrix is rotated in the plot) is the sum of the minimum distance across all samples of both time-series.

```{r, eval=FALSE}
AB.least.cost.matrix <- leastCostMatrix(
  distance.matrix = AB.distance.matrix
)

plotMatrix(distance.matrix = AB.least.cost.matrix)
```

**Optional** Get least cost path

```{r, eval=FALSE}
AB.least.cost.path <- leastCostPath(
  distance.matrix = AB.distance.matrix,
  least.cost.matrix = AB.least.cost.matrix
  )



```

```{r, eval=FALSE}
plotMatrix(distance.matrix = AB.distance.matrix,
           least.cost.path = AB.least.cost.path
           )
```


**3.** Getting the least cost value.

```{r, eval=FALSE}
AB.least.cost <- leastCost(least.cost.matrix = AB.least.cost.matrix)

AB.least.cost
```


**4.** Autosum, or sum of the distances among adjacent samples on each sequence.

```{r, eval=FALSE}
AB.autosum <- autoSum(
  sequences = AB.sequences,
  method = "manhattan"
  )

AB.autosum
```

**5.** Compute Psi

```{r, eval=FALSE}
AB.psi <- psi(least.cost = AB.least.cost,
              distance.matrix = AB.distance.matrix,
              autosum = AB.autosum)
AB.psi
```


```{r, eval=FALSE}
AB.psi.matrix <- psiToMatrix(psi.values = AB.psi)
```


# Workflow to compare multiple sequences

The dataset *sequencesMIS*...

```{r, eval=FALSE}
data(sequencesMIS)
kable(head(sequencesMIS, n=15))
```

Preparing the sequences

```{r, eval=FALSE}
MIS.sequences <- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  if.empty.cases = "zero",
  transformation = "hellinger"
)

str(MIS.sequences)
```

**1.** Computing the distance matrices

```{r, eval=FALSE, fig.width=12, fig.height=22}
MIS.distance.matrix <- distanceMatrix(
  sequences = MIS.sequences,
  grouping.column = "MIS"
)

plotMatrix(
  distance.matrix = MIS.distance.matrix,
  plot.columns = 6,
  plot.rows = 11,
  legend = FALSE
  )
```


**2.** Computing least cost.

```{r, fig.width=12, fig.height=22, eval=FALSE}
MIS.least.cost.matrix <- leastCostMatrix(
  distance.matrix = MIS.distance.matrix
)

plotMatrix(
  distance.matrix = MIS.least.cost.matrix,
  plot.columns = 6,
  plot.rows = 11,
  legend = FALSE
  )
```

**Optional** computing least cost path

```{r, fig.width=12, fig.height=22, eval=FALSE}
MIS.least.cost.path <- leastCostPath(
  distance.matrix = MIS.distance.matrix,
  least.cost.matrix = MIS.least.cost.matrix
  )

plotMatrix(
  distance.matrix = MIS.distance.matrix,
  least.cost.path = MIS.least.cost.path,
  plot.columns = 6,
  plot.rows = 11,
  legend = FALSE
  )
```

Plotting it


**3.** Getting the least cost value

```{r, eval=FALSE}
MIS.least.cost <- leastCost(least.cost.matrix = MIS.least.cost.matrix)

MIS.least.cost
```


**4.** Computing autosums

```{r, eval=FALSE}
MIS.autosum <- autoSum(
  sequences = MIS.sequences,
  grouping.column = "MIS",
  method = "manhattan"
  )

MIS.autosum
```


**5.** Computing psi

```{r, eval=FALSE}
MIS.psi <- psi(least.cost = MIS.least.cost,
               distance.matrix = MIS.distance.matrix,
               autosum = MIS.autosum)
MIS.psi
```

```{r, eval=FALSE}
MIS.psi.matrix <- psiToMatrix(psi.values = MIS.psi)
```

