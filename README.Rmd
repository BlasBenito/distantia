---
output: github_document
---

<!-- README.md is generated from README.Rmd. Please edit that file -->

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "man/figures/README-",
  out.width = "100%"
)

#installing required libraries
list.of.packages <- c("ggplot2", "viridis", "fields", "foreach", "parallel", "doParallel", "qgraph")
new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]
if(length(new.packages)) install.packages(new.packages, dep=TRUE)

```
# distantia

<!-- badges: start -->
<!-- badges: end -->

The package **distantia** allows to measure the dissimilarity between multivariate time-series (*sequences* hereafter). The package assumes that the target sequences are ordered along a given dimension, being depth and time the most common ones, but others such as latitude or elevation are also suitable. Furthermore, the target sequences can be regular or irregular, and have their samples aligned (same age/time/depth) or unaligned (different age/time/depth). The only requirement is that the sequences must have at least two (but ideally more) columns with the same name and units.

In this document I briefly explain the logics behind the method, show how to use it, and demonstrate how the **distantia** package introduces useful tools to compare multivariate time-series.

## Installation

You can install the released version of distantia from [CRAN](https://CRAN.R-project.org) with:

```{r, eval=FALSE}
# install.packages("distantia")
```

And the development version from [GitHub](https://github.com/) with:

```{r, eval=FALSE, message=FALSE}
install.packages("devtools")
devtools::install_github("BlasBenito/distantia")
```

Loading the library, plus other helper libraries:

```{r, message=FALSE, warning=FALSE, error=FALSE, eval=TRUE}
library(distantia)
library(ggplot2)
library(viridis)
library(kableExtra)
library(qgraph)
```


## Working with two irregular and unaligned sequences

### Preparing the data

This section assumes that the user wants to compare two sequences. The package provides two example datasets based on the Abernethy pollen core (Birks and Mathewes, 1978):

```{r, eval=TRUE}
data(sequenceA)
data(sequenceB)

str(sequenceA)
str(sequenceB)

kable(sequenceA, caption = "Sequence A")
kable(sequenceB, caption = "Sequence B")
```

Notice that **sequenceB** has a few NA values (that were introduced to serve as an example). The function **prepareSequences** gets them ready for analysis by matching colum names and handling empty data. It allows to merge two (or more) multivariate time-series into a single table ready for further analyses. Note that, since the data represents pollen abundances, a *Hellinger* transformation (square root of the relative proportions of each taxa) is applied.

```{r, eval=TRUE}
help(prepareSequences)

AB.sequences <- prepareSequences(
  sequence.A = sequenceA,
  sequence.A.name = "A",
  sequence.B = sequenceB,
  sequence.B.name = "B",
  merge.mode = "complete",
  if.empty.cases = "zero",
  transformation = "hellinger"
)

kable(AB.sequences)
```



### Computation of dissimilarity

The computation of dissimlarity between two sequences requires several steps.

**1. Computation of a distance matrix** among the samples of both sequences. It is computed by the **distanceMatrix** function, which allows the user to select a distance metric (so far the ones implemented are *manhattan*, *euclidean*, *chi*, and *hellinger*). The function **plotMatrix** allows an easy visualization of the distance matrix.

```{r, fig.width = 7, fig.height = 4, eval=TRUE, fig.cap = "Distance matrix of two irregular and unaligned multivariate sequences. Warmer colors indicate higher distance."}
#computing distance matrix
AB.distance.matrix <- distanceMatrix(
  sequences = AB.sequences,
  method = "manhattan"
)

#plotting distance matrix
plotMatrix(
  distance.matrix = AB.distance.matrix,
  color.palette = "viridis")
```

**2. Computation of the least-cost matrix within the distance matrix.** This step uses a *dynamic programming algorithm* to find the least-cost when moving between the cell 1,1 of the matrix (lower left in the image above) and the last cell of the matrix (opposite corner). It does so by solving first every partial solution (in the neighborhood of every cell in the matrix), and then propagating the sum towards the opposite extreme of the matrix. 

The value of the upper-right cell in the plotted matrix (actually, the lower-right cell in the actual data matrix, the matrix is rotated in the plot) is the sum of the minimum distance across all samples of both time-series.

```{r, fig.width = 7, fig.height = 4, eval=TRUE, fig.cap = "Least cumulative cost of moving between the lower-left cell and the upper-right cell. The value of the upper-right cell corresponds with the minimized sum of distances between the samples of both sequences."}
AB.least.cost.matrix <- leastCostMatrix(
  distance.matrix = AB.distance.matrix
)

plotMatrix(
  distance.matrix = AB.least.cost.matrix,
  color.palette = "viridis")
```

**Optional** In this optional step, the function **leastCostPath** finds the least-cost path in the matrix above. It returns a dataframe with the coordinates of the cells within the path, the distance between consecutive cells, and the cumulative distance of any given step in the path. It can be used to plot the path, which helps to better understand the alignmnet between both sequences. 

This dataframe will be used later on to generate other products, such the *slotting* of both sequences (a unique sequences with the samples of both sequences in the order that minimizes the distance between consecutive samples), or to transfer attributes such as age/time/depth from one sequence with them to another without them. **Note: these applications are not yet implemented**.
 
```{r, fig.width = 7, fig.height = 4, eval=TRUE, fig.cap = "least-cost path plotted on top of the distance matrix."}
AB.least.cost.path <- leastCostPath(
  distance.matrix = AB.distance.matrix,
  least.cost.matrix = AB.least.cost.matrix
  )

kable(AB.least.cost.path)

par(mfrow=c(2,1))
plotMatrix(
  distance.matrix = AB.distance.matrix,
  least.cost.path = AB.least.cost.path,
  color.palette = viridis(100, alpha = 0.7)
  )
```

```{r, fig.width = 7, fig.height = 4, eval=TRUE, fig.cap = "Least-cost path plotted on top of the least-cost matrix."}
plotMatrix(
  distance.matrix = AB.least.cost.matrix,
  least.cost.path = AB.least.cost.path,
  color.palette = viridis(100, alpha = 0.7)
  )
```

**3. Getting the least-cost value.** The Upper right cell of the least-cost matrix in the image of the least-cost matrix (lower right cell in the actual data-matrix) holds the cumulative sum of the least-cost path. This value will be used later to compute dissimilarity.

```{r, eval=TRUE}
AB.least.cost <- leastCost(
  least.cost.matrix = AB.least.cost.matrix
  )
AB.least.cost
```


**4. Autosum, or sum of the distances among adjacent samples on each sequence.** This is another requirement to compute a normalized measure of dissimilarity. It just computes the distance between adjacent samples of each sequence and sums them up. Notice that the output is a list with named slots. Lists are the main output device of this package, I'll explain later why.

```{r, eval=TRUE}
AB.autosum <- autoSum(
  sequences = AB.sequences,
  method = "manhattan"
  )
AB.autosum
```

**5. Compute dissimilarity.** The dissimilarity measure used in this package is named **psi**, that was first described in the book ["Numerical methods in Quaternary pollen analysis"](https://onlinelibrary.wiley.com/doi/abs/10.1002/gea.3340010406) (Birks and Gordon, 1985). **Psi** is computed as follows:

$$\psi = \frac{LC - (\sum{A_{i-j}} + \sum{B_{i-j}})}{\sum{A_{i-j}} + \sum{B_{i-j}}} $$

where:


+   $LC$ is the least-cost computed by **leastCostMatrix**.
+   $\sum{A_{i-j}}$ is the autosum of one of the sequences.
+   $\sum{B_{i-j}}$ is the autosum of the other sequence.

Which basically is the least-cost normalizado by the autosum of both sequences. The **psi** function only requires the least cost, and the autosum of both sequences, as follows. Notice that in the output list, the slot with the psi value is named after the two sequences separated by a vertical line ("A|B"). This convention will be followed by any function in the package that returns objects resulting from comparing two sequences.

```{r, eval=TRUE}
AB.psi <- psi(
  least.cost = AB.least.cost,
  autosum = AB.autosum)
AB.psi
```

The output of **psi** is a list, that can be transformed to a dataframe or a matrix by using the **formatPsi** function.

```{r}
#to dataframe
AB.psi.dataframe <- formatPsi(
  psi.values = AB.psi,
  to = "dataframe")
AB.psi.dataframe
```

```{r}
#to matrix
AB.psi.matrix <- formatPsi(
  psi.values = AB.psi,
  to = "matrix")
AB.psi.matrix
```

Or can also be transformed from matrix to dataframe, or from dataframe to matrix, as convenient.

```{r}
#from matrix to dataframe again
AB.psi.dataframe <- formatPsi(
  psi.values = AB.psi.matrix,
  to = "dataframe")
AB.psi.dataframe
```

```{r}
#or from dataframe to matrix
AB.psi.matrix <- formatPsi(
  psi.values = AB.psi.dataframe,
  to = "matrix"
)
AB.psi.matrix
```


All the steps required to compute **psi**, including the format options provided by **formatPsi** are wrapped together in the function **workflowPsi**, that works as follows:

```{r, eval=TRUE}
AB.psi <- workflowPsi(
  sequences = AB.sequences,
  grouping.column = "id",
  method = "manhattan",
  format = "dataframe"
)
AB.psi
```


# Workflow to compare multiple sequences

The package can work seamlessly with any given number of sequences, as long as there is memory enough available. To do so, almost every function uses the package ["foreach"](https://cran.r-project.org/web/packages/foreach/index.html), that allows to parallelize the execution of the functions by using all the processors in your machine but one. This speeds up operations considerably.

## Preparing the data

The example dataset *sequencesMIS* contains 12 sections of the same sequence belonging to different marine isotopic stages identified by a column named "MIS". MIS stages with odd numbers are interglacials, while the odd ones are glacials. 

```{r, eval=TRUE}
data(sequencesMIS)
kable(head(sequencesMIS, n=15))
unique(sequencesMIS$MIS)
```

The dataset is checked and prepared with **prepareSequences** (note the change in the argument *grouping.column*).

```{r, eval=TRUE}
MIS.sequences <- prepareSequences(
  sequences = sequencesMIS,
  grouping.column = "MIS",
  if.empty.cases = "zero",
  transformation = "hellinger"
)
```

The dissimilarity measure **psi** can be computed for every combination of sequences through the function **workflowPsi** shown below. Note the argument *output* that allows to select either "dataframe" (ordered from lower to higher dissimilarity) or "matrix" to obtain an output with a given structure (if empty, the function returns a list).


```{r, eval=TRUE}
MIS.psi <- workflowPsi(
  sequences = MIS.sequences,
  grouping.column = "MIS",
  time.column = NULL,
  exclude.columns = NULL,
  method = "manhattan",
  diagonal = FALSE,
  format = "dataframe"
)

#ordered with lower psi on top
kable(MIS.psi[order(MIS.psi$psi), ])
```



A dataframe like this can be plotted as an adjacency network with the **qgraph** package as follows:

```{r, fig.width = 7, fig.height = 7, eval=TRUE, fig.cap = "Similarity between MIS sequences represented as a network. More similar sites are closer, and linked by a wider edge. Note that glacials are colored in blue and interglacials in green"}
#psi values to matrix
MIS.psi.matrix <- formatPsi(
  psi.values = MIS.psi,
  to = "matrix"
)

#dissimilariy to distance
MIS.distance <- 1/MIS.psi.matrix**4

#plotting network
qgraph::qgraph(MIS.distance, 
       layout='spring', 
       vsize=5,
       labels = colnames(MIS.distance),
       colors = viridis::viridis(2, begin = 0.3, end = 0.8, alpha = 0.5, direction = -1)
       )

```

Or as a matrix with **ggplot2**.

```{r, fig.width = 7, fig.height = 4, eval=TRUE, fig.cap = "Dissimilarity between MIS sequences."}
#ordering factors to get a triangular matrix
MIS.psi$A <- factor(MIS.psi$A, levels=unique(sequencesMIS$MIS))
MIS.psi$B <- factor(MIS.psi$B, levels=unique(sequencesMIS$MIS))

#plotting matrix
ggplot(data=na.omit(MIS.psi), aes(x=A, y=B, size=psi, color=psi)) + 
  geom_point() +
  viridis::scale_color_viridis(direction = -1) +
  guides(size = FALSE)
```

The dataframe of dissimilarities between pairs of sequences can be also used to analyze the drivers of dissimilarity. To do so, attributes such as differences in time (when sequences represent different times) or distance (when sequences represent different sites) between sequences, or differences between physical/climatic attributes between sequences such as topography or climate can be added to the table, so models such as $psi = A + B + C$ (were A, B, and C are these attributes) can be fitted.

# Working with aligned multivariate time-series 

This section assumes that the target multivariate time-series have the same number of samples/rows, and samples have the same time/depth/order if there is a time/age/depth column available. In this particular case, distances are computed only between samples with the same time/depth/order, and no distance matrix (nor least cost analysis) is required. When the argument *paired.samples* in **prepareSequences** is set to TRUE, the function checks if the sequences have the same number of rows, and, if *time.column* is provided, it selects the samples that have valid time/depth columns for every sequence in the dataset.

Here we test these ideas with the **climate** dataset included in the library. It represents simulated palaeoclimate over 200 ky. at four sites identified by the column *sequenceId*. Note that this time the transformation applied is "scaled", which uses the **scale** function of R base to center and scale the data.

```{r, eval=TRUE}
#loading sample data
data(climate)

#preparing sequences
climate <- prepareSequences(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  paired.samples = TRUE,
  transformation = "scale"
  )
```

The function **distancePairedSamples** computes the between paired samples

The result is a list, each slot named as the id of the given sequence according to *grouping.columns*, and containing a vector with pairwise distances. Each vector position is named after *time.column* if available. 

```{r, eval=TRUE}
climate.distances <- distancePairedSamples(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  exclude.columns = NULL,
  method = "manhattan",
  sum.distances = FALSE
  )

str(climate.distances)
```

If the argument *sum.distances* is set to TRUE, it sums them up, doing in fact the same work done by **distanceMatrix**, **leastCostMatrix** and **leastCost** at once. 

```{r, eval=TRUE}
climate.distances <- distancePairedSamples(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  exclude.columns = NULL,
  method = "manhattan",
  sum.distances = TRUE
  )
climate.distances
```

Computing *psi* from there only requires the autosum of each sequence, and the application of the **psi** function.

```{r, eval=TRUE}
#computing autosum
climate.autosum <- autoSum(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  method = "manhattan"
)

#computing psi
climate.psi <- psi(
  least.cost = climate.distances,
  autosum = climate.autosum
)

climate.psi
```

These functions are wrapped together in the function **workflowPsiPaired**:

```{r, eval=TRUE}
climate.psi <- workflowPsiPairedSamples(
  sequences = climate,
  grouping.column = "sequenceId",
  time.column = "time",
  method = "manhattan",
  format = "dataframe"
)
kable(climate.psi)
```

# Variable contribution to dissimilarity

The dissimilarity measure *psi* is computed from the common columns of two datasets. But the partial contribution of given columns to *psi* can be computed, in order to answer questions such as "what columns/variables make the sequences more similar/different?"

```{r}

```



# Finding the section in a long sequence more similar to a given short sequence

