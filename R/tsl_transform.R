#' Transform Values of a Time Series List
#'
#' @description
#'
#' This is a custom wrapper for [base::lapply()] adapted to work with time series list. The objective of this function is data transformation without dimension changes. Check [tsl_resample()] and [tsl_aggregate()] for transformations requiring changes in data dimensions. Generally, functions introduced via the argument `f` should not change the dimensions of the output time series list. However, there are glaring exceptions. For example, [f_center()] and [f_scale()] compute the overall mean and standard deviation across all zoo objects in the time series list to apply a common transformation. This operation requires removing exclusive columns from the zoo objects via [tsl_remove_exclusive_cols()].
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for large time series lists.
#'
#' @param tsl (required, list of zoo objects) List of time series. Default: NULL
#' @param f (required, transformation function) name of a function taking a matrix as input. Currently, the following options are implemented, but any other function taking a matrix as input (for example, [scale()]) should work as well:
#' \itemize{
#'   \item f_proportion: proportion computed by row.
#'   \item f_percentage: percentage computed by row.
#'   \item f_hellinger: Hellinger transformation computed by row
#'   \item f_center: Centering computed by column using the column mean across all zoo objects within `tsl`.
#'   \item f_scale: Centering and scaling using the column mean and standard deviation across all zoo objects within `tsl`.
#'   \item f_smooth: Time series smoothing with a user defined rolling window.
#'   \item f_detrend_difference: Differencing detrending of time series via [diff()].
#'   \item f_detrend_linear: Detrending of seasonal time series via linear modeling.
#'   \item f_detrend_gam: Detrending of seasonal time series via Generalized Additive Models.
#' }
#' @param ... (optional, additional arguments of `f`) Optional arguments for the transformation function.
#'
#' @return time series list
#' @export
#' @autoglobal
#' @examples
#' #three time series
#' #climate and ndvi in Fagus sylvatica stands
#' #in Spain, Germany, and Sweden
#' data("fagus_dynamics")
#'
#' tsl <- tsl_initialize(
#'   x = fagus_dynamics,
#'   id_column = "site",
#'   time_column = "date"
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl
#'   )
#' }
#'
#' #parallelization setup (not worth it for this data size)
#' future::plan(
#'  future::multisession,
#'  workers = 2 #set to parallelly::availableWorkers() - 1
#' )
#'
#' #progress bar
#' progressr::handlers(global = TRUE)
#'
#' #list of transformation functions
#' #-----------------------------------------
#' f_list()
#'
#' #centering
#' #-----------------------------------------
#' #global centering based on
#' #mean of each variable
#' #across all time series
#' tsl_center <- tsl_transform(
#'   tsl = tsl,
#'   f = f_center
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_center,
#'     guide_columns = 3
#'   )
#' }
#'
#'
#' #centering and scaling
#' #-----------------------------------------
#' #same mean and standard deviation are used to scale each variable across all time series
#' tsl_scale <- tsl_transform(
#'   tsl = tsl,
#'   f = f_scale
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_scale,
#'     guide_columns = 3
#'   )
#' }
#'
#' #also, with scale()
#' #centers and scales each variable independently of the others
#' #offers very similar results as f_scale for this case, but it might not work as well for other datasets
#' tsl_scale <- tsl_transform(
#'   tsl = tsl,
#'   f = base::scale,
#'   center = TRUE,
#'   scale = TRUE
#' )
#'
#'
#' #rescaling to a new range
#' #-----------------------------------------
#'
#' #old range
#' sapply(X = tsl, FUN = range)
#'
#' #rescale between -100 and 100
#' tsl_rescaled <- tsl_transform(
#'   tsl = tsl,
#'   f = f_rescale,
#'   new_min = -100,
#'   new_max = 100
#' )
#'
#' #new range
#' sapply(X = tsl_rescaled, FUN = range)
#'
#'
#' #rounding to n digits
#' #-----------------------------------------
#'
#' #old range
#' sapply(X = tsl, FUN = range)
#'
#' #rounding to zero digits
#' tsl_round <- tsl_transform(
#'   tsl = tsl,
#'   f = round,
#'   digits = 0
#' )
#'
#' #new range
#' sapply(X = tsl_round, FUN = range)
#'
#'
#' #moving window smoothing
#' #-----------------------------------------
#' #default values
#' tsl_smooth_mean <- tsl_transform(
#'   tsl = tsl,
#'   f = f_smooth_window,
#'   smoothing_window = 3, #default
#'   smoothing_f = mean #default
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_smooth_mean,
#'     guide_columns = 3
#'   )
#' }
#'
#' #different smoothing window and function
#' tsl_smooth_max <- tsl_transform(
#'   tsl = tsl,
#'   f = f_smooth_window,
#'   smoothing_window = 5,
#'   smoothing_f = max
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_smooth_max,
#'     guide_columns = 3
#'   )
#' }
#'
#' #principal components
#' #-----------------------------------------
#' #replaces original variables with their principal components
#' #requires centering and/or scaling
#' tsl_pca <- tsl |> tsl_transform(
#'   f = f_scale
#' ) |>
#'   tsl_transform(
#'     f = f_pca
#'   )
#'
#' #returns principal components
#' tsl_colnames(tsl = tsl_pca)
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_pca,
#'     guide_columns = 3
#'   )
#' }
#'
#' #detrending
#' #-----------------------------------------
#' #monthly temperatures in major cities
#' data("cities_temperature")
#'
#' #subset Abidjan (city with higher temperature slope)
#' tsl <- tsl_initialize(
#'   x = cities_temperature,
#'   id_column = "city",
#'   time_column = "date"
#' ) |> tsl_subset(
#'   names = "Abidjan"
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl,
#'     color = "red4"
#'   )
#' }
#'
#' #LINEAR DETRENDING
#' tsl_detrend_linear <- tsl_transform(
#'   tsl = tsl,
#'   f = f_detrend_linear,
#'   center = FALSE #to keep temperature scale
#' )
#'
#' #show effect of linear detrending
#' if(interactive()){
#'   plot(tsl[[1]]$temperature, col = "blue")
#'   lines(tsl_detrend_linear[[1]]$temperature, col = "red4")
#' }
#'
#' #rename to join with the original tsl for plotting
#' tsl_detrend_linear <- tsl_names_set(
#'   tsl = tsl_detrend_linear,
#'   names = "detrend_linear"
#'   )
#'
#' #DIFFERENCES DETRENDING with lag 1 (monthly lag)
#' tsl_detrend_difference_1 <- tsl_transform(
#'   tsl = tsl,
#'   lag = 1,
#'   f = f_detrend_difference,
#'   center = FALSE
#' )
#'
#' #rename to join with the original tsl for plotting
#' tsl_detrend_difference_1 <- tsl_names_set(
#'   tsl = tsl_detrend_difference_1,
#'   names = "difference_lag_1"
#' )
#'
#' #DIFFERENCES DETRENDING with lag 12 (yearly lag)
#' tsl_detrend_difference_12 <- tsl_transform(
#'   tsl = tsl,
#'   lag = 12,
#'   f = f_detrend_difference,
#'   center = FALSE
#' )
#'
#' #rename to join with the original tsl for plotting
#' tsl_detrend_difference_12 <- tsl_names_set(
#'   tsl = tsl_detrend_difference_12,
#'   names = "difference_lag_12"
#' )
#'
#' #join original data and detrended versions
#' tsl <- c(
#'   tsl,
#'   tsl_detrend_linear,
#'   tsl_detrend_difference_1,
#'   tsl_detrend_difference_12
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl,
#'     color = "red4"
#'   )
#' }
#'
#'
#' #compare original vs detrended data using f_trend_linear()
#' tsl_linear_trend <- tsl_transform(
#'   tsl = tsl,
#'   f = f_trend_linear
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_linear_trend,
#'     color = "red4"
#'   )
#' }
#'
#' #numeric transformations
#' #-----------------------------------------
#' #pollen counts from different interglacials
#' data("mis")
#'
#' #load as tsl
#' tsl <- tsl_initialize(
#'   x = mis,
#'   id_column = "mis",
#'   time_column = "sample_order"
#' )
#'
#' #subset first three time-series
#' tsl <- tsl[1:3]
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl
#'   )
#' }
#'
#' #transform to proportions
#' tsl_proportion <- tsl_transform(
#'   tsl = tsl,
#'   f = f_proportion
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_proportion
#'   )
#' }
#'
#' #percentages
#' tsl_percentage <- tsl_transform(
#'   tsl = tsl,
#'   f = f_percentage
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_percentage
#'   )
#' }
#'
#' #hellinger transformation
#' tsl_hellinger <- tsl_transform(
#'   tsl = tsl,
#'   f = f_hellinger
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl_hellinger
#'   )
#' }
#'
#' #custom functions
#' #-----------------------------------------
#'
#' #multiply by a scalar y
#' #the custom function must return a zoo object
#' tsl_new <- tsl_transform(
#'   tsl = tsl,
#'   f = function(x, y) x * y,
#'   y = 100
#' )
#'
#' #same as:
#' #much faster, no requirement to return a zoo object
#' #can be replaced with a parallelized future_lapply
#' tsl_new <- lapply(
#'   X = tsl,
#'   FUN = function(x, y) x * y,
#'   y = 100
#' )
#'
#' #disable parallelization
#' future::plan(
#'   future::sequential
#' )
tsl_transform <- function(
    tsl = NULL,
    f = NULL,
    ...
){

  if(is.function(f) == FALSE){

    stop(
      "Argument 'f' must be a function name with no quotes. Valid options are: ",
      paste(
        f_list(),
        collapse = ", "
      ),
      "."
    )

  }

  tsl <- tsl_is_valid(
    tsl = tsl
  )

  na.count <- tsl_count_NA(
    tsl = tsl,
    verbose = FALSE
  ) |>
    suppressWarnings()

  if(na.count > 0){
    stop("There are ", na.count, " NA, NaN, or Inf cases in argument 'tsl', Please handle these cases with distantia::tsl_handle_NA() before applying a transformation.")
  }

  #progress bar
  p <- progressr::progressor(along = tsl)

  #apply centering and or scaling
  if(
    all(
      c(
        "center",
        "scale"
      )
      %in%
      names(formals(f))
    )
  ){

    #remove exclusive columns
    tsl <- tsl_remove_exclusive_cols(
      tsl = tsl
    )

    #compute global scaling parameters
    scaling_params <- utils_global_scaling_params(
      tsl = tsl,
      f = f,
      ... = ...
    )

    # scaling with scaling params
    # TODO: need to document this feature in examples
    tsl <- future.apply::future_lapply(
      X = tsl,
      FUN = function(x){

        p()

        f(
          x = x,
          center = scaling_params$center,
          scale = scaling_params$scale
        )

      }
    )


  } else{

    #apply other transformation function
    tsl <- future.apply::future_lapply(
      X = tsl,
      FUN = function(x, ...){

        p()

        f(
          x = x,
          ... = ...
          )

      }
    )


  }


  #reset names of zoo objects
  tsl <- tsl_names_set(
    tsl = tsl
  )

  na.count <- tsl_count_NA(
    tsl = tsl,
    verbose = TRUE
  )

  tsl

}
