#' Plot Distance or Cost Matrix
#'
#' @description
#' This function is a simplified version of [fields::imagePlot()], by [Douglas Nychka](https://dnychka.github.io/). The original version is recommended in case more customization than the provided here is needed.
#'
#'
#' @param m (required, numeric matrix) distance or cost matrix generated by [distance_matrix()] or [cost_matrix()], but any numeric matrix will work. Default: NULL
#' @param col (optional, character vector) vector of colors. Default: `grDevices::hcl.colors(n = 100, palette = "Zissou 1")`.
#' @param main_title (optional, character string) plot title. Default: NULL
#' @param xlab (optional, character string) title of the x axis (matrix columns). Default: NULL
#' @param ylab (optional, character string) title of the y axis (matrix rows). Default: NULL
#' @param guide_title (optional, character string) title of the color guide. Default: NULL
#' @param path (optional, data frame) least cost path generated with [cost_path()]. This data frame must have the attribute `type == "cost_path`, or otherwise it will be ignored. Default: NULL.
#' @param path_width (optional, numeric) width of the least-cost path. Default: 1
#' @param path_color (optional, character string) color of the least-cost path. Default: "black"
#' @param cex (optional, numeric) multiplicator for the text size. Default: 1
#'
#' @return A plot
#' @examples
#'
#' #' library(distantia)
#'
#' load("~/Dropbox/GITHUB/R_packages/distantia/data/sequencesMIS.RData")
#'
#' #data frame with grouping column
#' ###################################
#' data(sequencesMIS)
#'
#' #prepare list of sequences
#' x <- prepare_sequences(
#'   x = sequencesMIS,
#'   id_column = "MIS",
#'   time_column = NULL,
#'   paired_samples = FALSE,
#'   pseudo_zero =  0.001,
#'   na_action = "to_zero"
#' )
#'
#' #distance matrix of the first two sequences
#' dist_matrix <- distance_matrix(
#'   a = x[[1]],
#'   b = x[[2]],
#'   distance = "euclidean"
#' )
#'
#' #cost matrix
#' cost_matrix <- cost_matrix(
#'   dist_matrix = dist_matrix
#'   )
#'
#' #least cost path
#' path <- cost_path(
#'   dist_matrix = dist_matrix,
#'   cost_matrix = cost_matrix
#' )
#'
#' #plot cost matrix and least cost path
#' plot_matrix(
#'   m = cost_matrix,
#'   path = path
#'   )
#'
#' @export
#' @autoglobal
plot_matrix <- function(
    m = NULL,
    m_colors = grDevices::hcl.colors(
      n = 100,
      palette = "Zissou 1"
    ),
    main_title = NULL,
    xlab = NULL,
    ylab = NULL,
    guide_title = NULL,
    path = NULL,
    path_width = 1,
    path_color = "black",
    cex = 1
){

  #a few hardcoded guide parameters
  guide_area_factor <- 0.1
  guide_width = 1.2
  guide_margin <- 5.1

  #text sizes
  main_title_cex <- 1 * cex
  main_axis_title_cex <- 0.9 * cex
  main_axis_labels_cex <- 0.8 * cex
  guide_title_cex <- 0.8 * cex
  guide_axis_labels_cex <- 0.7 * cex

  #title distances
  guide_title_distance <- 0.75
  main_title_distance <- 1.2
  main_axis_title_distance <- 2.2

  if(inherits(x = m, what = "matrix") == FALSE){
    stop("Argument 'm' must be a distance or cost matrix resulting from distantia::distance_matrix() or distantia::cost_matrix().")
  }

  #handling cost path
  if("cost_path" %in% attributes(path)$type){

    #rename path columns
    colnames(path)[colnames(path) == "a"] <- attributes(path)$a_name
    colnames(path)[colnames(path) == "b"] <- attributes(path)$b_name

  } else {

    if(!is.null(path)){

      warning("Argument 'path' was not generated with distantia::cost_path() and will be ignored.")
      path <- NULL

    }

  }

  #save and reset the user's graphical parameters
  old.par <- par(no.readonly = TRUE)
  on.exit(par(old.par))

  #main plotting parameters
  y <- seq_len(nrow(m))
  x <- seq_len(ncol(m))
  z <- t(m)

  #handling dimension names
  a_name <- attributes(m)$a_name
  a_name <- ifelse(
    test = is.null(a_name),
    yes = "a",
    no = a_name
  )

  b_name <- attributes(m)$b_name
  b_name <- ifelse(
    test = is.null(b_name),
    yes = "a",
    no = b_name
  )

  #handling axis labels
  y_labels <- dimnames(m)[[1]] |>
    as.numeric() |>
    pretty()

  x_labels <- dimnames(m)[[2]] |>
    as.numeric() |>
    pretty()

  #handling breaks

  limz <- range(z, na.rm = TRUE)

  a <- seq(
    from = limz[1],
    to = limz[2],
    length.out = length(m_colors)
  )

  b <- (a[2]- a[1])/2

  breaks <- c(a[1] - b, a + b)

  #handling main and guide area
  old.par <- par(no.readonly = TRUE)
  text_size <- par()$cin[1]/par()$din[1]
  offset <- text_size * par()$mar[4]
  guide_width <- text_size * guide_width
  guide_margin <- guide_margin * text_size
  guide_area <- old.par$plt
  guide_area[2] <- 1 - guide_margin
  guide_area[1] <- guide_area[2] - guide_width
  pr <- (guide_area[4] - guide_area[3]) * ((guide_area_factor)/2)
  guide_area[4] <- guide_area[4] - pr
  guide_area[3] <- guide_area[3] + pr

  #handling main area
  main_area <- old.par$plt
  main_area[2] <- min(main_area[2], guide_area[1] - offset)
  guide_area[1] <- min(main_area[2] + offset, guide_area[1])
  guide_area[2] <- guide_area[1] + (guide_area[2] - guide_area[1])

  #main plot
  par(plt = main_area)
  graphics::image(
    x = x,
    y = y,
    z = z,
    breaks = breaks,
    col = m_colors,
    xlab = "",
    ylab = "",
    axes = FALSE,
    useRaster = FALSE,
    add = FALSE
  )

  graphics::title(
    xlab = b_name,
    line = main_axis_title_distance,
    cex.lab = main_axis_title_cex
  )

  graphics::title(
    ylab = a_name,
    line = main_axis_title_distance,
    cex.lab = main_axis_title_cex
  )

  graphics::title(
    main = ifelse(
      test = is.null(main_title),
      yes = paste0(a_name, " vs. ", b_name),
      no = main_title
    ),
    cex.main = main_title_cex,
    line = main_title_distance
  )

  axis(
    1,
    at = x_labels,
    cex.axis = main_axis_labels_cex
  )

  axis(
    2,
    at = y_labels,
    cex.axis = main_axis_labels_cex
  )

  if(!is.null(path)){
    graphics::lines(
      x = path[[b_name]],
      y = path[[a_name]],
      lwd = path_width,
      col = path_color
    )
  }

  big.par <- par(no.readonly = TRUE)

  #PLOT LEGEND
  if(
    (guide_area[2] > guide_area[1]) &&
    (guide_area[4] > guide_area[3])
  ){

    #guide values
    guide_values <- (
      breaks[1:(length(breaks)-1)] +
        breaks[2:length(breaks)]
    )/2

    #guide title
    if(is.null(guide_title)){

      distance <- attributes(m)$distance

      if(is.character(distance)){
        distance <- tools::toTitleCase(distance)
      }

      type <- attributes(m)$type

      if("distance" %in% type){

        guide_title <- ifelse(
          test = is.null(distance),
          yes = "Distance",
          no = paste(distance , "\ndistance")
        )

      }

      if("cost" %in% type){

        guide_title <- ifelse(
          test = is.null(distance),
          yes = "Cost",
          no = paste(distance , "\ncost")
        )

      }

    }

    #guide plot
    par(
      new = TRUE,
      pty = "m",
      plt = guide_area,
      err = -1
    )

    graphics::image(
      x = 1:2,
      y = breaks,
      z = matrix(
        guide_values,
        nrow = 1,
        ncol = length(guide_values)
      ),
      xaxt = "n",
      yaxt = "n",
      xlab = "",
      ylab = "",
      col = col,
      breaks = breaks
    )

    graphics::title(
      main = guide_title,
      cex.main = guide_title_cex,
      line = guide_title_distance
    )

    #guide axis
    do.call(
      what = "axis",
      args = list(
        side = 4,
        mgp = c(3, 1, 0),
        las = 2,
        cex.axis = guide_axis_labels_cex
      )
    )

  } else {

    warning("Plotting area is too small to add a color guide.")

  }

  invisible()

}

