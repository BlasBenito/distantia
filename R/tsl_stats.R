#' Summary Statistics of Time Series Lists
#'
#' @description
#' This function computes a variety of summary statistics for each time series and numeric column within time series list. The statistics include common metrics  such as minimum, maximum, quartiles, mean, standard deviation, range, interquartile range, skewness, kurtosis, and autocorrelation for specified lags.
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for large time series lists.
#'
#' @param tsl (required, list) Time series list. Default: NULL
#' @param ac_lags (optional, integer) An integer specifying the number of autocorrelation lags to compute. Default: 1.
#'
#' @return data frame:
#' \itemize{
#' \item name: The name of the time series (derived from the list names).
#' \item rows: Number of rows in the time series.
#' \item columns: Number of columns in the time series.
#' \item time_units: Character string describing the time units.
#' \item time_begin: Earliest time point in the time series.
#' \item time_end: Latest time point in the time series.
#' \item time_length: Length of the time series, experssed in time_units.
#' \item time_resolution: Average distance between consecutive samples.
#' \item variable: Name of the variable (column) for which statistics are computed.
#' \item min: Minimum value of the variable.
#' \item q1: First quartile (25th percentile) of the variable.
#' \item median: Median value of the variable.
#' \item q3: Third quartile (75th percentile) of the variable.
#' \item max: Maximum value of the variable.
#' \item mean: Mean value of the variable.
#' \item sd: Standard deviation of the variable.
#' \item range: Range of the variable, computed as max - min.
#' \item iq_range: Interquartile range (IQR) of the variable, computed as q3 - q1.
#' \item skewness: Skewness of the variable, a measure of asymmetry in the distribution.
#' \item kurtosis: Kurtosis of the variable, a measure of the "tailedness" of the distribution.
#' \item ac_lag_1, ac_lag_2, ...: Autocorrelation values for the specified number of lags. The column names will correspond to the lag values (e.g., \code{ac_lag_1}, \code{ac_lag_2}).
#' }
#'
#' @examples
#' TODO: add example
#'
#' @export
#' @autoglobal
tsl_stats <- function(
    tsl = NULL,
    ac_lags = 1
){

  tsl <- tsl_is_valid(
    tsl = tsl
  )

  ac_lags <- as.integer(ac_lags)
  if(ac_lags < 1){
    ac_lags <- 1
  }


  #subset numeric columns
  tsl <- tsl_subset(
    tsl = tsl,
    numeric_cols = TRUE,
    shared_cols = FALSE
  )

  #progress bar
  p <- progressr::progressor(along = tsl)

  #
  `%iterator%` <- doFuture::`%dofuture%`

  #computing stats
  #TODO: this is failing with the fagus_dynamics dataset
  df <- foreach::foreach(
    i = seq_len(length(tsl))
  ) %iterator% {

    # p()

    #general details of the zoo objects
    zoo.i <- tsl[[i]]

    zoo.i.time <- zoo_time(x = zoo.i)

    zoo.i.data <- zoo::coredata(zoo.i)
    zoo.i.index <- zoo::index(zoo.i)

    zoo.i.details <- data.frame(
      name = zoo.i.time$name,
      rows = zoo.i.time$rows,
      colums = ncol(zoo.i.data),
      time_units = zoo.i.time$units,
      time_begin = zoo.i.time$begin,
      time_end = zoo.i.time$end,
      time_length = zoo.i.time$length,
      time_resolution = zoo.i.time$resolution,
      variable = colnames(zoo.i.data)
    )

    zoo.i.details.names <- names(zoo.i.details)

    #column stats
    zoo.i.stats <- sapply(
      X = zoo.i,
      FUN = function(x){

        n <- length(x)

        #autocorrelation
        x.ac <- stats::acf(
          x = as.numeric(x),
          lag.max = ac_lags,
          plot = FALSE
          )$acf |>
          as.vector() |>
          utils::tail(n = ac_lags) |>
          t() |>
          as.data.frame()

        names(x.ac) <- paste0(
          "ac_lag_",
          seq_len(ac_lags)
        )

        #column stats
        x.stats <- data.frame(
          min = min(x, na.rm = TRUE),
          q1 = stats::quantile(x, probs = 0.25),
          median = stats::median(x = x, na.rm = TRUE),
          q3 = stats::quantile(x, probs = 0.75),
          max = max(x, na.rm = TRUE),
          mean = mean(x, na.rm = TRUE),
          sd = stats::sd(x, na.rm = TRUE)
        )

        #ranges
        x.stats$range <- x.stats$max - x.stats$min
        x.stats$iq_range <- x.stats$q3 - x.stats$q1

        #skewness
        x.stats$skewness <- sum((x - x.stats$mean)^3, na.rm = TRUE) / (n * x.stats$sd^3)

        #kurtosis
        x.stats$kurtosis <- sum((x - x.stats$mean)^4, na.rm = TRUE) / (n * x.stats$sd^4) - 3 * (n - 1)^2 / ((n - 2) * (n - 3))

        x.stats <- cbind(
          x.stats,
          x.ac
        )

        return(x.stats)

      }
    ) |>
      t() |>
      as.data.frame()

    zoo.i.stats.names <- names(zoo.i.stats)

    zoo.i.stats$variable <- row.names(zoo.i.stats)
    rownames(zoo.i.stats) <- NULL

    #merging general details and column stats
    zoo.i.df <- merge(
      zoo.i.details,
      zoo.i.stats
    )

    #reorder columns after merge
    zoo.i.df <- zoo.i.df[
      ,
      c(zoo.i.details.names, zoo.i.stats.names)
      ]

    return(zoo.i.df)

  }

  df

}
