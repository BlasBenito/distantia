#' Plot Distance or Cost Matrix and Least Cost Path
#'
#' @description
#' This function is a simplified version of [fields::imagePlot()], by [Douglas Nychka](https://dnychka.github.io/). The original version is recommended in case more customization than the provided here is needed.
#'
#'
#' @param m (required, numeric matrix) distance or cost matrix generated by [psi_dist_matrix()] or [psi_cost_matrix()], but any numeric matrix will work. Default: NULL
#' @param color (optional, character vector) vector of colors. Uses the palette "Zissou 1" by default. Default: NULL
#' @param title (optional, character string) plot title. By default, names of the sequences used to compute the matrix `m`. Default: NULL
#' @param subtitle (optional, character string) plot subtitle. Default: NULL
#' @param xlab (optional, character string) title of the x axis (matrix columns). By default, the name of one of the sequences used to compute the matrix `m`. Default: NULL
#' @param ylab (optional, character string) title of the y axis (matrix rows). By default, the name of one of the sequences used to compute the matrix `m`. Default: NULL
#' @param text_cex (optional, numeric) multiplicator of the text size for the plot labels and titles. Default: 1
#' @param path (optional, data frame) least cost path generated with [psi_cost_path()]. This data frame must have the attribute `type == "cost_path`, and must have been computed from the same sequences used to compute the matrix `m`. Default: NULL.
#' @param path_width (optional, numeric) width of the least-cost path. Default: 1
#' @param path_color (optional, character string) color of the least-cost path. Default: "black"
#' @param guide (optional, logical) if TRUE, a color guide for the matrix `m` is added by [utils_matrix_guide()].
#' @param subpanel (optional, logical) internal argument used when generating the multipanel plot produced by [distantia_plot()].
#'
#' @return A plot
#' @examples
#'
#' #data frame with grouping column
#' ###################################
#' data(mis)
#'
#' #prepare list of sequences
#' x <- tsl_initialize(
#'   x = mis,
#'   id_column = "MIS"
#' )
#'
#' #distance matrix of the first two sequences
#' dist_matrix <- psi_dist_matrix(
#'   x = x[[1]],
#'   y = x[[2]],
#'   distance = "euclidean"
#' )
#'
#' #cost matrix
#' cost_matrix <- psi_cost_matrix(
#'   dist_matrix = dist_matrix
#'   )
#'
#' #least cost path
#' path <- psi_cost_path(
#'   dist_matrix = dist_matrix,
#'   cost_matrix = cost_matrix
#' )
#'
#' #plot cost matrix and least cost path
#' utils_matrix_plot(
#'   m = cost_matrix,
#'   path = path,
#'   guide = TRUE
#'   )
#'
#' @export
#' @autoglobal
utils_matrix_plot <- function(
    m = NULL,
    color = NULL,
    title = NULL,
    subtitle = NULL,
    xlab = NULL,
    ylab = NULL,
    text_cex = 1,
    path = NULL,
    path_width = 1,
    path_color = "black",
    guide = TRUE,
    subpanel = FALSE
){

  #First to upper
  firstup <- function(x) {
    substr(x, 1, 1) <- toupper(substr(x, 1, 1))
    x
  }

  # Preserve user's config
  if(subpanel == FALSE){
    old.par <- graphics::par(no.readonly = TRUE)
    on.exit(graphics::par(old.par))
  }

  #check m
  m <- utils_check_matrix_args(m = m)

  #specific behaviours by matrix type
  m_type <- attributes(m)$type

  #generic matrix
  if(is.null(m_type)){
    stop("Plotting for generic matrices is not implemented yet")
  }

  #distance matrix
  if(m_type %in% c("distance", "cost")){

    guide_title <- paste0(
      attributes(m)$distance,
      "\ndistance"
      )

    x_name <- attributes(m)$x_name
    y_name <- attributes(m)$y_name

    if(is.null(title)){
      title <- paste0(
        attributes(m)$y_name,
        " vs. ",
        attributes(m)$x_name
        )
    }

    if(is.null(xlab)){
      xlab <- x_name
    }

    if(is.null(ylab)){
      ylab <- y_name
    }

    #get axes time
    axis_x_labels <- attributes(m)$x_time
    axis_y_labels <- attributes(m)$y_time

    #to pretty
    axis_x_labels_pretty <- pretty(x = axis_x_labels)
    axis_y_labels_pretty <- pretty(x = axis_y_labels)

    #axis positions closest to pretty version
    axis_x_at <- lapply(
      X = axis_x_labels_pretty,
      FUN = function(x){
        which.min(abs(as.numeric(x - axis_x_labels)))
      }
    ) |>
      unlist()

    axis_y_at <- lapply(
      X = axis_y_labels_pretty,
      FUN = function(x){
        which.min(abs(as.numeric(x - axis_y_labels)))
      }
    ) |>
      unlist()

    axis_x_labels <- attributes(axis_x_labels_pretty)$labels
    axis_y_labels <- attributes(axis_y_labels_pretty)$labels

    #get tick locations
    # axis_x_at <- seq_len(length(axis_x_labels))
    # axis_y_at <- seq_len(length(axis_y_labels))

  }

  #psi matrix
  if(m_type == "distantia_matrix"){

    if(is.null(title)){
      title <- "Dissimilarity Matrix"
    }

    guide_title <- "Psi \ndistance"

    if(is.null(xlab)){
      xlab <- ""
    }

    if(is.null(ylab)){
      ylab <- ""
    }

    axis_x_at <- seq_len(ncol(m))
    axis_y_at <- seq_len(nrow(m))

    axis_x_labels <- axis_y_labels <- dimnames(m)[[2]]

  }

  guide_title <- firstup(x = guide_title)

  #axis title
  #leave more space if axis needs dates
  if(
    class(attributes(m)$x_time) %in% c("Date", "POSIXct") &&
    subpanel == FALSE
    ){

    axis_title_distance <- 4
    axis_labels_cex <- 0.6 * text_cex

  } else {

    axis_title_distance <- 2.2
    axis_labels_cex <- 0.8 * text_cex

  }

  #title cex
  axis_title_cex <- 0.9 * text_cex

  #plotting areas
  plt_all <- graphics::par()$plt
  plt_m <- plt_all

  if(guide == TRUE){

    plt_m <- c(
      plt_m[1],
      plt_m[2] - 0.1,
      plt_m[3],
      plt_m[4]
    )

    plt_guide <- c(
      plt_m[2] + 0.02,
      plt_all[2] - 0.05,
      plt_m[3],
      plt_m[4]
    )

  }

  #title
  main_title_distance <- ifelse(
    test = is.null(subtitle),
    yes = 1.2,
    no = 2
  )
  main_title_cex <- 1.2 * text_cex

  #subtitle
  subtitle_distance <- 0.5
  subtitle_cex <- 1 * text_cex

  if(is.null(color)){
    color = utils_color_continuous_default(
      n = 100
    )
  }

  breaks <- utils_color_breaks(
    m = m,
    n = length(color)
  )

  graphics::par(
    plt = plt_m
  )

  #plot matrix
  graphics::image(
    x = seq_len(ncol(m)),
    y = seq_len(nrow(m)),
    z = t(m),
    breaks = breaks,
    col = color,
    xlab = "",
    ylab = "",
    axes = FALSE,
    useRaster = FALSE,
    add = FALSE
  )

  if(subpanel == FALSE){

    graphics::title(
      xlab = xlab,
      line = axis_title_distance,
      cex.lab = axis_title_cex
    )

    graphics::title(
      ylab = ylab,
      line = axis_title_distance,
      cex.lab = axis_title_cex
    )


      graphics::axis(
        side = 1,
        at = axis_x_at,
        labels = axis_x_labels,
        cex.axis = axis_labels_cex,
        las = 2
      )

      graphics::axis(
        side = 2,
        at = axis_y_at,
        labels = axis_y_labels,
        cex.axis = axis_labels_cex,
        las = 2
      )

  }

  graphics::title(
    main = title,
    cex.main = main_title_cex,
    line = main_title_distance
  )

  # matrix subtitle ----
  if(!is.null(subtitle)){

    graphics::mtext(
      side = 3,
      line = subtitle_distance,
      at = NA,
      adj = NA,
      padj = NA,
      outer = FALSE,
      cex = subtitle_cex,
      subtitle
    )

  }

  # least cost path ----
  if(!is.null(path)){

    path <- utils_check_path_args(
      path = path
    )

    if(
      attributes(path)$y_name != y_name ||
      attributes(path)$x_name != x_name
    ){
      stop("Arguments 'm' and 'path' must be computed for the same sequences.")
    }

    #rename path columns
    colnames(path)[colnames(path) == "y"] <- y_name
    colnames(path)[colnames(path) == "x"] <- x_name

    #plot cost path
    graphics::lines(
      x = path[[attributes(m)$x_name]],
      y = path[[attributes(m)$y_name]],
      lwd = path_width,
      col = path_color
    )


  }

  #guide
  if(guide == TRUE){

    graphics::par(
      plt = plt_guide,
      new = TRUE
    )

    utils_matrix_guide(
      m = m,
      color = color,
      breaks = breaks,
      title = guide_title,
      text_cex = text_cex
    )

  }

  invisible()

}
