#' Dissimilarity Model Frame
#'
#' @description
#' This function generates a model frame for statistical or machine learning analysis from these objects:
#'
#' \itemize{
#'   \item: Dissimilarity data frame generated by [distantia()]. The output model frame will have as many rows as this data frame.
#'   \item: Data frame with static descriptors of the time series. These descriptors are converted to distances between pairs of time series via [distance_matrix()].
#'   \item: List defining new predictors as combinations of other existing predictors. This feature allows grouping together predictors that have a common meaning. For example, `predictors_list = list(temperature = c("temperature_mean", "temperature_min", "temperature_max")` generates a new predictor named "temperature", which results from computing the distances of the vector of temperature variables for each pair of time series. Predictors in one of such groups will be scaled before distance computation if their maximum standard deviations differ by a factor of 10 or more.
#' }
#'
#'
#' The resulting data frame contains the following columns:
#' \itemize{
#'   \item `x` and `y`: names of the pair of time series represented in the row.
#'   \item `psi`: dissimilarity between `x` and `y`.
#'   \item predictors columns: representing the distance between the values of the given static predictor between `x` and `y`.
#'   \item (optional) `distance`:If the static predictors data frame is an `sf` object, then this predictor is created via `sf::st_distance()`.
#' }
#'
#' Statistical or machine learning analyses based on this data frame may help uncover drivers of dissimilarity. Model coefficients or importance scores generated from this model frame represent the effect of the distance between predictors on the dissimilarity between time seriess.
#'
#' This function supports a parallelization setup via [future::plan()], and progress bars provided by the package [progressr](https://CRAN.R-project.org/package=progressr).
#'
#'
#' @inheritParams distantia_matrix
#' @param predictors_df (required, data frame) data frame with numeric predictors to be added to the model frame. Must have a column with the names in `df$x` and `df$y`. If `sf` data frame, the predictor "distance" is added to the model frame. Default: NULL
#' @param predictors_list (optional, list) list defining new predictors as combinations of other predictors in `predictors_df`. For example, `predictors_list = list(a = c("b", "c"))` uses the columns `"b"` and `"c"` from `predictors_df` to generate the predictor `a` in the model frame. Default: NULL
#' @param predictors_scaled (optional, logical) if TRUE, all predictors are scaled and centered with [scale()]. Default: FALSE
#' @inheritParams distantia
#'
#' @return data frame: with attributes "response", "predictors" and "formula".
#' @export
#' @autoglobal
#' @examples
#'
#' #covid prevalence in California counties
#' tsl <- tsl_initialize(
#'   x = covid_prevalence,
#'   name_column = "name",
#'   time_column = "time"
#' )
#'
#' #dissimilarity analysis
#' df <- distantia(
#'   tsl = tsl,
#'   lock_step = TRUE
#' )
#'
#' #combine several predictors
#' #into a new one
#' predictors_list <- list(
#'   economy = c(
#'     "poverty_percentage",
#'     "median_income",
#'     "domestic_product"
#'     )
#' )
#'
#' #generate model frame
#' model_frame <- distantia_model_frame(
#'   df = df,
#'   predictors_df = covid_counties,
#'   predictors_list = predictors_list,
#'   predictors_scaled = TRUE
#' )
#'
#' head(model_frame)
#'
#' #names of response and predictors
#' #and an additive formula
#' #are stored as attributes
#' attributes(model_frame)$response
#' attributes(model_frame)$predictors
#' attributes(model_frame)$formula
#'
#'
#' #linear model
#' model <- lm(
#'   formula = attributes(model_frame)$formula,
#'   data = model_frame
#' )
#'
#' summary(model)
#'
#' @family dissimilarity_analysis_main
distantia_model_frame <- function(
    df = NULL,
    predictors_df = NULL,
    predictors_list = NULL,
    predictors_scaled = FALSE,
    distance = "euclidean"
){

  #df ----
  if(is.null(df)){

    stop(
      "distantia::distantia_model_frame(): argument `df' must not be NULL.",
      call. = FALSE
    )

  }

  if(attributes(df)$type != "distantia_df"){

    stop(
      "distantia::distantia_model_frame(): argument 'df' must be the output of distantia::distantia().",
      call. = FALSE
    )

  }

  #simplify distantia data frame
  df <- distantia_aggregate(
    df = df,
    f = mean
  )

  #add ID
  df$id <- seq_len(nrow(df))

  #predictors_df ----
  if(is.null(predictors_df)){

    stop(
      "distantia::distantia_model_frame(): argument `predictors_df' must not be NULL.",
      call. = FALSE
    )

  }

  if(!inherits(x = predictors_df, what = "data.frame")){

    stop(
      "distantia::distantia_model_frame(): argument `predictors_df' must be a data frame.",
      call. = FALSE
    )

  }

  #identify names column in predictors df
  df_names <- unique(
    c(df$x, df$y)
  )

  predictors_name_column <- sapply(
    X = predictors_df,
    FUN = function(x){
      sum(df_names %in% x) == length(df_names)
    }
  )

  predictors_name_column <- names(predictors_name_column[which(predictors_name_column)])

  if(length(predictors_name_column) == 0){
    stop(
      "distantia::distantia_model_frame(): argument 'predictors_df' must have a column with the names in 'df$x' and 'df$y'.",
      call. = FALSE
    )
  }

  #numeric columns
  predictors_numeric_columns <- sapply(
    X = predictors_df,
    FUN = is.numeric
  )

  predictors_numeric_columns <- names(predictors_numeric_columns[which(predictors_numeric_columns)])

  if(length(predictors_numeric_columns) == 0){
    stop(
      "distantia::distantia_model_frame(): argument 'predictors_df' must have at least one numeric column, but it has none.",
      call. = FALSE
    )
  }

  #predictors list ----

  #default predictors list
  predictors_list_default <- as.list(
    predictors_numeric_columns
  )

  names(predictors_list_default) <- predictors_numeric_columns

  #predictors list
  if(is.null(predictors_list)){

    predictors_list <- predictors_list_default

  } else {

    #add names if not named
    if(is.null(names(predictors_list))){
      names(predictors_list) <- sapply(
        X = predictors_list,
        FUN = function(x){
          paste(x, collapse = "_")
        }
      )
    }

    predictors_list_default <- predictors_list_default[!(names(predictors_list_default) %in% names(predictors_list))]

    predictors_list <- c(
      predictors_list,
      predictors_list_default
    )

  }

  #remove geometry
  predictors_df_no_geom <- utils_drop_geometry(
    df = predictors_df
    )

  #id df
  df.id <- df[, "id", drop = FALSE]

  #progress bar
  p <- progressr::progressor(along = predictors_list)

  #compute distance matrices
  model_frame_list <- future.apply::future_lapply(
    X = seq_len(length(predictors_list)),
    FUN = function(x){

      p()

      #extract predictors columns
      df.i <- predictors_df_no_geom[
        ,
        unlist(predictors_list[[x]]),
        drop = FALSE
        ]

      #decide if scaling is needed
      sd_ratios <- max(sapply(X = df.i, FUN = sd)) /
        min(sapply(X = df.i, FUN = sd))

      if(sd_ratios > 10){

        df.i <- df.i |>
          scale() |>
          as.data.frame()

      }

      #add name column
      df.i[[predictors_name_column]] <- predictors_df[[predictors_name_column]]

      #compute distance matrix
      m.i <- distantia::distance_matrix(
        df = df.i,
        name_column = predictors_name_column,
        distance = distance
      )

      #prepare df
      out.df.i <- df.id

      #extract matrix as vector
      variable.i <- mapply(
        FUN = function(a, b) m.i[a, b],
        df$x,
        df$y
      )

      names(variable.i) <- NULL

      out.df.i[[names(predictors_list)[x]]] <- variable.i

      out.df.i

    },
    future.seed = NULL
  )

  names(model_frame_list) <- names(predictors_list)

  #add geographic distance if predictors_df is an sf data frame
  if(
    !is.null(attributes(predictors_df)$sf_column) &&
    requireNamespace("sf", quietly = TRUE) &&
    requireNamespace("lwgeom", quietly = TRUE)
  ){

    m.i <- sf::st_distance(
      x = predictors_df
    )

    dimnames(m.i) <- list(
      as.character(predictors_df[[predictors_name_column]]),
      as.character(predictors_df[[predictors_name_column]])
    )

    variable.i <- mapply(
      FUN = function(a, b) m.i[a, b],
      df$x,
      df$y
    )

    names(variable.i) <- NULL

    new_distance_column <- "distance"
    if(new_distance_column %in% names(model_frame_list)){
      new_distance_column <- "geometry_distance"
    }

    df.id[[new_distance_column]] <- variable.i

    #add to model frame list
    model_frame_list <- c(
      list(distance = df.id),
      model_frame_list
    )

  }

  predictors_names <- names(model_frame_list)

  #add distantia df
  model_frame_list <- c(
    list(response = df),
    model_frame_list
  )

  #join all data frames
  model_frame <- Reduce(
    f = function(x, y){
      merge(x, y, by = "id")
    },
    x = model_frame_list
  )

  model_frame$id <- NULL

  #scale
  if(predictors_scaled == TRUE){

    model_frame <- cbind(
      psi = model_frame$psi,
      model_frame[, predictors_names] |>
        scale() |>
        as.data.frame()
    )

  }

  attr(
    x = model_frame,
    which = "response"
  ) <- "psi"

  attr(
    x = model_frame,
    which = "predictors"
  ) <- predictors_names

  attr(
    x = model_frame,
    which = "formula"
  ) <- stats::as.formula(
    paste(
      "psi ~ ",
      paste(predictors_names, collapse = " + ")
    )
  )

  model_frame


}
