# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Auto Distance
#' @description Computes the distance matrix between the rows of two matrices
#' \code{y} and \code{x} with the same number of columns and arbitrary numbers of rows.
#' NA values should be removed before using this function.
#' If the selected distance function is [distance_chi_cpp], pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param m (required, numeric matrix) multivariate time series.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#'  of the dataset `distances`. Default: "euclidean".
#' @return Matrix of distances between 'y' (rows) and 'x' (columns).
#' @export
auto_distance_cpp <- function(m, distance = "euclidean") {
    .Call(`_distantia_auto_distance_cpp`, m, distance)
}

#' Subset Matrix by Rows
#' @description Subsets the matrix \code{m} to the indices given in the vector \code{rows}.
#' Used to subset a sequence to the coordinates of a trimmed least-cost path.
#' @param m (required, numeric matrix) a sequence.
#' @param rows (required, integer vector) vector of rows to subset.
#' @return Numeric matrix of length rows.
#' @export
subset_matrix_by_rows_cpp <- function(m, rows) {
    .Call(`_distantia_subset_matrix_by_rows_cpp`, m, rows)
}

#'Auto Sum of Two Time Series
#' @description Sum of the the cumulative auto-sum of two sequences with paired samples. This is
#' a key component of the psi computation.
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Auto sum of distances.
#' @export
auto_sum_no_path_cpp <- function(x, y, distance = "euclidean") {
    .Call(`_distantia_auto_sum_no_path_cpp`, x, y, distance)
}

#'Auto-sum of Two Sequences
#' @description Sum of the the cumulative auto-sum of two sequences. This is
#' a key component of the psi computation.
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param path (required, data frame) dataframe produced by [cost_path_cpp()].
#' Default: NULL
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Numeric.
#' @export
auto_sum_path_cpp <- function(x, y, path, distance = "euclidean") {
    .Call(`_distantia_auto_sum_path_cpp`, x, y, path, distance)
}

#' Least Cost Matrix Considering Diagonals
#' @description Computes the least cost matrix from a distance matrix.
#' Considers diagonals during computation of least-costs.
#' @param dist_matrix (required, distance matrix). Square distance matrix, output of [distance_matrix_cpp()].
#' @return Least cost matrix.
#' @export
cost_matrix_diag_cpp <- function(dist_matrix) {
    .Call(`_distantia_cost_matrix_diag_cpp`, dist_matrix)
}

#' Least Cost Matrix with Weighted Diagonals
#' @description Computes the least cost matrix from a distance matrix.
#' Weights diagonals by a factor of 1.414214 with respect to orthogonal paths.
#' @param dist_matrix (required, distance matrix). Distance matrix.
#' @return Least cost matrix.
#' @export
cost_matrix_weighted_diag_cpp <- function(dist_matrix) {
    .Call(`_distantia_cost_matrix_weighted_diag_cpp`, dist_matrix)
}

#' Least Cost Matrix
#' @description Computes the least cost matrix from a distance matrix.
#' @param dist_matrix (required, distance matrix). Output of [distance_matrix_cpp()].
#' @return Least cost matrix.
#' @export
cost_matrix_cpp <- function(dist_matrix) {
    .Call(`_distantia_cost_matrix_cpp`, dist_matrix)
}

#' Least Cost Path for Sequence Slotting
#' @description Computes the least cost matrix from a distance matrix.
#' Considers diagonals during computation of least-costs. This version differs
#' from cost_path_cpp() in the way it solves ties. In the case of a tie,
#' cost_path_cpp() uses the first neighbor satisfying the minimum distance condition,
#' while cost_path_slotting_cpp() selects the neighbor that changes the axis
#' of movement within the least cost matrix.
#' @param dist_matrix (required, distance matrix). Distance matrix.
#' @param cost_matrix (required, numeric matrix) Cost matrix generated from the distance matrix.
#' @return A data frame with least-cost path coordiantes.
#' @export
cost_path_slotting_cpp <- function(dist_matrix, cost_matrix) {
    .Call(`_distantia_cost_path_slotting_cpp`, dist_matrix, cost_matrix)
}

#' Least Cost Path
#' @description Computes the least cost matrix from a distance matrix.
#' Considers diagonals during computation of least-costs.
#' @param dist_matrix (required, distance matrix). Distance matrix.
#' @param cost_matrix (required, numeric matrix) Cost matrix generated from the distance matrix.
#' @return A data frame with least-cost path coordiantes.
#' @export
cost_path_cpp <- function(dist_matrix, cost_matrix) {
    .Call(`_distantia_cost_path_cpp`, dist_matrix, cost_matrix)
}

#' Least Cost Path Considering Diagonals
#' @description Computes the least cost matrix from a distance matrix.
#' Considers diagonals during computation of least-costs. In case of ties,
#' diagonals are favored.
#' @param dist_matrix (required, distance matrix). Distance matrix.
#' @param cost_matrix (required, numeric matrix) Cost matrix generated from the distance matrix.
#' @return A data frame with least-cost path coordiantes.
#' @export
cost_path_diag_cpp <- function(dist_matrix, cost_matrix) {
    .Call(`_distantia_cost_path_diag_cpp`, dist_matrix, cost_matrix)
}

#' Trims Blocks from Least Cost Path
#' @param path (required, data frame) dataframe produced by [cost_path_cpp()]. Default: NULL
#' @return A data frame with least-cost path coordinates.
#' @export
cost_path_trim_cpp <- function(path) {
    .Call(`_distantia_cost_path_trim_cpp`, path)
}

#' Sum of Least Cost Distance Times Two
#' @param path (required, data frame) dataframe produced by [cost_path_cpp()]. Default: NULL
#' @return Sum of distances
#' @export
cost_path_sum_cpp <- function(path) {
    .Call(`_distantia_cost_path_sum_cpp`, path)
}

#' Distance Matrix
#' @description Computes the distance matrix between the rows of two matrices
#' \code{y} and \code{x} with the same number of columns and arbitrary numbers
#' of rows.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Matrix of distances between 'y' (rows) and 'x' (columns).
#' @export
#' @name distance_matrix_cpp
distance_matrix_cpp <- function(x, y, distance = "euclidean") {
    .Call(`_distantia_distance_matrix_cpp`, x, y, distance)
}

#' Sum of Pairwise Distances Between Paired Sequences
#' @description Computes the lock-step sum of distances between two time series.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns and rows as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Vector of distances between 'y' (rows) and 'x' (columns).
#' @export
distance_lock_step_cpp <- function(y, x, distance = "euclidean") {
    .Call(`_distantia_distance_lock_step_cpp`, y, x, distance)
}

#' Chebyshev Distance Between Two Vectors
#' @description Computed as: \code{max(abs(x - y))}. Cannot handle NA values.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Chebyshev distance between x and y.
#' @examples distance_chebyshev_cpp(x = runif(100), y = runif(100))
#' @export
distance_chebyshev_cpp <- function(x, y) {
    .Call(`_distantia_distance_chebyshev_cpp`, x, y)
}

#' Jaccard Distance Between Two Binary Vectors
#' @description Computes the Jaccard distance between two binary vectors.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Jaccard distance between x and y.
#' @examples distance_jaccard_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
#' @export
distance_jaccard_cpp <- function(x, y) {
    .Call(`_distantia_distance_jaccard_cpp`, x, y)
}

#' Manhattan Distance Between Two Vectors
#' @description Computed as: \code{sum(abs(x - y))}. Cannot handle NA values.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Manhattan distance between x and y.
#' @examples distance_manhattan_cpp(x = runif(100), y = runif(100))
#' @export
distance_manhattan_cpp <- function(x, y) {
    .Call(`_distantia_distance_manhattan_cpp`, x, y)
}

#' Euclidean Distance Between Two Vectors
#' @description Computed as: \code{sqrt(sum((x - y)^2)}. Cannot handle NA values.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Euclidean distance between x and y.
#' @examples distance_euclidean_cpp(x = runif(100), y = runif(100))
#' @export
distance_euclidean_cpp <- function(x, y) {
    .Call(`_distantia_distance_euclidean_cpp`, x, y)
}

#' Hellinger Distance Between Two Vectors
#' @description Computed as: \code{sqrt(1/2 * sum((sqrt(x) - sqrt(y))^2))}.
#' Cannot handle NA values.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Hellinger distance between x and y.
#' @examples distance_hellinger_cpp(x = runif(100), y = runif(100))
#' @export
distance_hellinger_cpp <- function(x, y) {
    .Call(`_distantia_distance_hellinger_cpp`, x, y)
}

#' Normalized Chi Distance Between Two Vectors
#' @description Computed as:
#' \code{xy <- x + y}
#' \code{y. <- y / sum(y)}
#' \code{x. <- x / sum(x)}
#' \code{sqrt(sum(((x. - y.)^2) / (xy / sum(xy))))}.
#' Cannot handle NA values. When \code{x} and \code{y} have zeros in the same
#' position, \code{NaNs} are produced. Please replace these zeros with
#' pseudo-zeros (i.e. 0.0001) if you wish to use this distance metric.
#' @examples distance_chi_cpp(x = runif(100), y = runif(100))
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Chi distance between x and y.
#' @export
distance_chi_cpp <- function(x, y) {
    .Call(`_distantia_distance_chi_cpp`, x, y)
}

#' Canberra Distance Between Two Binary Vectors
#' @description Computes the Canberra distance between two binary vectors.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.//' @return Canberra distance between x and y.
#' @examples distance_canberra_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
#' @export
distance_canberra_cpp <- function(x, y) {
    .Call(`_distantia_distance_canberra_cpp`, x, y)
}

#' Russell-Rao Distance Between Two Binary Vectors
#' @description Computes the Russell-Rao distance between two binary vectors.
#' @param x (required, numeric). Binary vector of 1s and 0s.
#' @param y (required, numeric) Binary vector of 1s and 0s of same length as `x`.
#' @return Russell-Rao distance between x and y.
#' @examples distance_russelrao_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
#' @export
distance_russelrao_cpp <- function(x, y) {
    .Call(`_distantia_distance_russelrao_cpp`, x, y)
}

#' Cosine Dissimilarity Between Two Vectors
#' @description Computes the cosine dissimilarity between two numeric vectors.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Cosine dissimilarity between x and y.
#' @examples distance_cosine_cpp(c(0.2, 0.4, 0.5), c(0.1, 0.8, 0.2))
#' @export
distance_cosine_cpp <- function(x, y) {
    .Call(`_distantia_distance_cosine_cpp`, x, y)
}

#' Hamming Distance Between Two Binary Vectors
#' @description Computes the Hamming distance between two binary vectors.
#' @param x (required, numeric vector).
#' @param y (required, numeric vector) of same length as `x`.
#' @return Hamming distance between x and y.
#' @examples distance_hamming_cpp(c(0, 1, 0, 1), c(1, 1, 0, 0))
#' @export
distance_hamming_cpp <- function(x, y) {
    .Call(`_distantia_distance_hamming_cpp`, x, y)
}

reverse_vector_cpp <- function(x) {
    .Call(`_distantia_reverse_vector_cpp`, x)
}

update_path_dist_cpp <- function(x, y, path, distance = "euclidean") {
    .Call(`_distantia_update_path_dist_cpp`, x, y, path, distance)
}

select_column_cpp <- function(x, column_index) {
    .Call(`_distantia_select_column_cpp`, x, column_index)
}

delete_column_cpp <- function(x, column_index) {
    .Call(`_distantia_delete_column_cpp`, x, column_index)
}

#' Contribution of Individual Columns to Overall Psi Distance for Paired Sequences
#' @description Computes the distance psi between two matrices
#' \code{y} and \code{x} with the same number of columns and rows. Distances
#' between \code{y} and \code{x} are computed row wise rather than via distance
#' matrix and least-cost path computation.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Psi distance
#' @export
importance_lock_step_cpp <- function(x, y, distance = "euclidean") {
    .Call(`_distantia_importance_lock_step_cpp`, x, y, distance)
}

#' Classic Computation of Variable Importance
#' @description Returns the contribution of each variable to the overall dissimilarity
#' of two sequences. In opposition to the robust version, least-cost paths for each combination
#' of variables are computed independently. To compute importance,
#' the function first computes the psi distance dissimilarity between seuqences
#' using all columns ("psi"), with each column separately ("psi_only_with"),
#' and without each column ("psi_without). Then, it computes "psi_difference" as
#' psi_only_with - psi_without. Highest positive values in this column represent the
#' variables that better explain the dissimilarity between the sequences.
#' @description Computes the psi distance between y and x using all columns,
#' with each column, and without each column
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical). If TRUE, diagonal is set to TRUE, and
#' diagonal cost is weighted by a factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @return Data frame with psi distances
#' @export
importance_cpp <- function(y, x, distance = "euclidean", diagonal = TRUE, weighted = TRUE, ignore_blocks = FALSE) {
    .Call(`_distantia_importance_cpp`, y, x, distance, diagonal, weighted, ignore_blocks)
}

#' Robust Computation of Variable Importance
#' @description Returns the contribution of each variable to the overall dissimilarity
#' of two sequences. In opposition to the classic version, importance computation is
#' performed over the least-cost path of the whole sequence. To compute importance,
#' the function first computes the psi distance dissimilarity between seuqences
#'  using all columns ("psi"), with each column separately ("psi_only_with"),
#'  and without each column ("psi_without). Then, it computes "psi_difference" as
#' psi_only_with - psi_without. Highest positive values highlight the variables that
#' better explain the dissimilarity between the sequences.
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical). If TRUE, diagonal is set to TRUE, and
#' diagonal cost is weighted by a factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @return Data frame with psi distances
#' @export
importance_robust_cpp <- function(x, y, distance = "euclidean", diagonal = FALSE, weighted = FALSE, ignore_blocks = FALSE) {
    .Call(`_distantia_importance_robust_cpp`, x, y, distance, diagonal, weighted, ignore_blocks)
}

#' Restricted Permutation of Complete Rows Within Blocks
#' @description Divides a sequence in blocks of a given size and permutes rows
#' within these blocks.
#' Larger block sizes increasingly disrupt the data structure over time.
#' @param x (required, numeric matrix). Numeric matrix to permute.
#' @param block_size (optional, integer) block size in number of rows.
#' Minimum value is 2, and maximum value is nrow(x).
#' @param seed (optional, integer) random seed to use.
#' @return Numeric matrix, permuted version of x.
#' @export
permute_restricted_by_row_cpp <- function(x, block_size, seed = 1L) {
    .Call(`_distantia_permute_restricted_by_row_cpp`, x, block_size, seed)
}

#' Unrestricted Permutation of Complete Rows
#' @description Unrestricted shuffling of rows within the whole sequence.
#' @param x (required, numeric matrix). Numeric matrix to permute.
#' @param block_size (optional, integer) this function ignores this argument and sets it to x.nrow().
#' @param seed (optional, integer) random seed to use.
#' @return Numeric matrix, permuted version of x.
#' @export
permute_free_by_row_cpp <- function(x, block_size, seed = 1L) {
    .Call(`_distantia_permute_free_by_row_cpp`, x, block_size, seed)
}

#' Restricted Permutation of Cases Within Blocks
#' @description Divides a sequence or time-series in blocks and permutes cases
#' within these blocks. This function does not preserve rows, and should not be
#' used if the sequence has dependent columns.
#' Larger block sizes increasingly disrupt the data structure over time.
#' @param x (required, numeric matrix). Numeric matrix to permute.
#' @param block_size (optional, integer) block size in number of rows.
#' Minimum value is 2, and maximum value is nrow(x).
#' @param seed (optional, integer) random seed to use.
#' @return Numeric matrix, permuted version of x.
#' @export
permute_restricted_cpp <- function(x, block_size, seed = 1L) {
    .Call(`_distantia_permute_restricted_cpp`, x, block_size, seed)
}

#' Unrestricted Permutation of Cases
#' @description Unrestricted shuffling of cases within the whole sequence.
#' @param x (required, numeric matrix). Numeric matrix to permute.
#' @param block_size (optional, integer) this function ignores this argument and sets it to x.nrow().
#' @param seed (optional, integer) random seed to use.
#' @return Numeric matrix, permuted version of x.
#' @export
permute_free_cpp <- function(x, block_size, seed = 1L) {
    .Call(`_distantia_permute_free_cpp`, x, block_size, seed)
}

#' Generates Least Cost Path
#' @description Least cost path between two sequences \code{y} and \code{x}
#' with the same number of columns and arbitrary numbers of rows to compute the
#' ABbetween component of the psi dissimilarity computation.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical). If TRUE, diagonal is set to TRUE, and
#' diagonal cost is weighted by y factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @return Data frame with least cost path
#' @export
psi_cost_path_cpp <- function(x, y, distance = "euclidean", diagonal = TRUE, weighted = TRUE, ignore_blocks = FALSE) {
    .Call(`_distantia_psi_cost_path_cpp`, x, y, distance, diagonal, weighted, ignore_blocks)
}

#' Auto Sum of Two Sequences
#' @description Cumulative sum times two of two sequences \code{y} and \code{x}
#' with the same number of columns and arbitrary numbers of rows to compute the
#' ABwithin component of the psi dissimilarity computation. This component is
#' used to normalize the least cost distance between the sequences.
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param path (required, data frame) dataframe produced by [cost_path_cpp()].
#' Default: NULL
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @return Auto sum of matrices y and x.
#' @export
psi_auto_sum_cpp <- function(x, y, path, distance = "euclidean", ignore_blocks = FALSE) {
    .Call(`_distantia_psi_auto_sum_cpp`, x, y, path, distance, ignore_blocks)
}

#' Psi Dissimilarity Metric
#' @description Computes the psi dissimilarity score between two sequences from
#' their least cost path and their auto sums.
#' @param path (required, data frame) dataframe produced by [cost_path_cpp()].
#' Default: NULL
#' @param auto_sum (required, numeric) auto sum of both sequences,
#' result of [psi_auto_sum_cpp()].
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @return Numeric, psi dissimilarity
#' @export
psi_formula_cpp <- function(path, auto_sum, diagonal = TRUE) {
    .Call(`_distantia_psi_formula_cpp`, path, auto_sum, diagonal)
}

#' Computes Psi Distance Between Two Time-Series With Paired Samples
#' @description Computes the distance psi between two matrices
#' \code{y} and \code{x} with the same number of columns and rows. Distances
#' between \code{y} and \code{x} are computed row wise rather than via distance
#' matrix and least-cost path computation.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @return Psi distance
#' @export
psi_lock_step_cpp <- function(x, y, distance = "euclidean") {
    .Call(`_distantia_psi_lock_step_cpp`, x, y, distance)
}

#' Null Distribution of Psi Distances Between Two Paired Time-Series
#' @description Computes null psi distances for permuted versions of the paired sequences
#' \code{y} and \code{x} with the same number of rows and columns.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param y (required, numeric matrix) of same number of columns as 'x'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param repetitions (optional, integer) number of null psi values to generate. Default: 100
#' @param permutation (optional, character) permutation method. Valid values are listed below from higher to lower randomness:
#' \itemize{
#'   \item "free": unrestricted shuffling of rows and columns. Ignores block_size.
#'   \item "free_by_row": unrestricted shuffling of complete rows. Ignores block size.
#'   \item "restricted": restricted shuffling of rows and columns within blocks.
#'   \item "restricted_by_row": restricted shuffling of rows within blocks.
#' }
#' @param block_size (optional, integer) block size in rows for
#' restricted permutation. A block size of 3 indicates that a row can only be permuted
#' within a block of 3 adjacent rows. Minimum value is 2. Default: 3.
#' @param seed (optional, integer) initial random seed to use for replicability. Default: 1
#' @return Numeric vector with null distribution of psi distances.
#' @export
null_psi_lock_step_cpp <- function(x, y, distance = "euclidean", repetitions = 100L, permutation = "restricted_by_row", block_size = 3L, seed = 1L) {
    .Call(`_distantia_null_psi_lock_step_cpp`, x, y, distance, repetitions, permutation, block_size, seed)
}

#' Computes Psi Distance Between Two Time-Series
#' @description Computes the distance psi between two matrices
#' \code{y} and \code{x} with the same number of columns and arbitrary numbers of rows.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical). If TRUE, diagonal is set to TRUE, and
#' diagonal cost is weighted by a factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @return Psi distance
#' @export
psi_cpp <- function(x, y, distance = "euclidean", diagonal = TRUE, weighted = TRUE, ignore_blocks = FALSE) {
    .Call(`_distantia_psi_cpp`, x, y, distance, diagonal, weighted, ignore_blocks)
}

#' Null Distribution of Psi Distances Between Two Time-Series
#' @description Computes null psi distances for permuted versions of the sequences
#' \code{y} and \code{x} with the same number of columns and arbitrary numbers of rows.
#' NA values should be removed before using this function.
#' If the selected distance function is "chi" or "cosine", pairs of zeros should
#' be either removed or replaced with pseudo-zeros (i.e. 0.00001).
#' @param y (required, numeric matrix).
#' @param x (required, numeric matrix) of same number of columns as 'y'.
#' @param distance (optional, character string) name or abbreviation of the
#' distance method. Valid values are in the columns "names" and "abbreviation"
#' of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical). If TRUE, diagonals are included in the
#' computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical). If TRUE, diagonal is set to TRUE, and
#' diagonal cost is weighted by a factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical). If TRUE, blocks of consecutive path
#' coordinates are trimmed to avoid inflating the psi distance. This argument
#' has nothing to do with block_size!. Default: FALSE.
#' @param repetitions (optional, integer) number of null psi values to generate. Default: 100
#' @param permutation (optional, character) permutation method. Valid values are listed below from higher to lower randomness:
#' \itemize{
#'   \item "free": unrestricted shuffling of rows and columns. Ignores block_size.
#'   \item "free_by_row": unrestricted shuffling of complete rows. Ignores block size.
#'   \item "restricted": restricted shuffling of rows and columns within blocks.
#'   \item "restricted_by_row": restricted shuffling of rows within blocks.
#' }
#' @param block_size (optional, integer) block size in rows for
#' restricted permutation. A block size of 3 indicates that a row can only be permuted
#' within a block of 3 adjacent rows. Minimum value is 2. Default: 3.
#' @param seed (optional, integer) initial random seed to use for replicability. Default: 1
#' @return Numeric vector with null distribution of psi distances.
#' @export
null_psi_cpp <- function(x, y, distance = "euclidean", diagonal = TRUE, weighted = TRUE, ignore_blocks = FALSE, repetitions = 100L, permutation = "restricted_by_row", block_size = 3L, seed = 1L) {
    .Call(`_distantia_null_psi_cpp`, x, y, distance, diagonal, weighted, ignore_blocks, repetitions, permutation, block_size, seed)
}

