#' Slots two sequences into a single composite sequence.
#'
#' @description Generates a composite sequence, constrained by sample order, from two sequences, by minimizing the dissimilarity between adjacent samples of each input sequence. The algorithm computes the distance matrix, least cost matrix, and least cost path of two sequences, and uses the least cost path file to find the slotting that better minimizes the dissimilarity between adjacent samples. The algorithm assumes that the samples are not aligned or paired.
#'
#'
#' @usage sequenceSlotting(
#'   sequences = NULL,
#'   grouping.column = NULL,
#'   time.column = NULL,
#'   exclude.columns = NULL,
#'   method = "manhattan",
#'   plot = TRUE
#'   )
#'
#' @param sequences dataframe with multiple sequences identified by a grouping column generated by \code{\link{prepareSequences}}. The dataframe must contain only two sequences differentiated by \code{grouping.column}.
#' @param grouping.column character string, name of the column in \code{sequences} to be used to identify separates sequences within the file.
#' @param time.column character string, name of the column with time/depth/rank data.
#' @param exclude.columns character string or character vector with column names in \code{sequences} to be excluded from the analysis.
#' @param method character string naming a distance metric. Valid entries are: "manhattan", "euclidean", "chi", and "hellinger". Invalid entries will throw an error.
#' @param plot boolean, if \code{TRUE}, plots the distance matrix and the least-cost path.
#'
#' @return A dataframe with the same number of rows as \code{sequences}, ordered according to the best solution found by the least-cost algorithm.
#'
#' @author Blas Benito <blasbenito@gmail.com>
#'
#' @examples
#'
#' \dontrun{
#' #loading the data
#' data(pollenGP)
#'
#' #getting first 20 samples
#' pollenGP <- pollenGP[1:20, ]
#'
#' #sampling indices
#' set.seed(10) #to get same result every time
#' sampling.indices <- sort(sample(1:20, 10))
#'
#' #subsetting the sequence
#' A <- pollenGP[sampling.indices, ]
#' B <- pollenGP[-sampling.indices, ]
#'
#' #preparing the sequences
#' AB <- prepareSequences(
#'   sequence.A = A,
#'   sequence.A.name = "A",
#'   sequence.B = B,
#'   sequence.B.name = "B",
#'   grouping.column = "id",
#'   exclude.columns = c("depth", "age"),
#'   transformation = "hellinger"
#'   )
#'
#' AB.combined <- sequenceSlotting(
#'   sequences = AB,
#'   grouping.column = "id",
#'   time.column = "age",
#'   exclude.columns = "depth",
#'   method = "manhattan",
#'   plot = TRUE
#'   )
#'
#' AB.combined
#'
#'}
#'
#'@export
sequenceSlotting <- function(sequences = NULL,
                             grouping.column = NULL,
                             time.column = NULL,
                             exclude.columns = NULL,
                             method = "manhattan",
                             plot = TRUE){

  #checking there are only two sequences
  if(is.null(grouping.column)){
    stop("The argument 'grouping.column' is empty.")
  } else {
    if(length(unique(sequences[, grouping.column])) != 2){
      stop("The argument 'sequences' must be a dataframe with two sequences identified by 'grouping.column'. The dataframe provided does not have two sequences.")
    }
  }

  #distance matrix
  distance.matrix <- distanceMatrix(
    sequences = sequences,
    grouping.column = grouping.column,
    time.column = time.column,
    exclude.columns = exclude.columns,
    method = method,
    parallel.execution = FALSE
  )

  #least cost matrix
  least.cost.matrix <- leastCostMatrix(
    distance.matrix = distance.matrix,
    diagonal = FALSE,
    parallel.execution = FALSE
  )

  #least cost path
  least.cost.path <- leastCostPath(
    distance.matrix = distance.matrix,
    least.cost.matrix = least.cost.matrix,
    diagonal = FALSE,
    parallel.execution = FALSE
  )

  #visualizing output
  if(plot == TRUE){
    plotMatrix(
      distance.matrix = distance.matrix,
      least.cost.path = least.cost.path,
      color.palette = "viridis"
    )
  }

  #sequence names
  sequence.names <- unique(sequences[, grouping.column])

  #extracting and flipping least.cost.path
  path <- least.cost.path[[1]]
  path <- path[nrow(path):1, ]

  #adding index column to the sequences
  for(k in 1:2){
    sequences[sequences[, grouping.column] == sequence.names[k], "index"] <- order(unique(path[, sequence.names[k]]))
  }

  #creating output dataframe
  sequences.combined <- sequences
  sequences.combined[] <- NA

  #list of indices of each sequence to be used
  indices <- list()
  indices[[1]] <- path[, sequence.names[1]]
  indices[[2]] <- path[, sequence.names[2]]
  names(indices) <- sequence.names

  #starting values for dynamic variables
  target.sequence <- sequence.names[1]
  target.index <- indices[[target.sequence]][1]

  #iterating through AB.index.unique
  ##################################
  for(j in 1:nrow(sequences.combined)){

    if(target.index %in% indices[[target.sequence]]){

      #target.index is repeated in target.sequence
      if(sum(indices[[target.sequence]] == target.index) > 1){

        #switch sequence
        target.sequence <- sequence.names[sequence.names != target.sequence]

        #change target.index to the first index of the given sequence
        target.index <- indices[[target.sequence]][1]

        #adds the line to sequences.combined
        sequences.combined[j, ] <- sequences[which(sequences[ , grouping.column] == target.sequence & sequences$index == target.index), ]

        #removes the index from the given sequence
        indices[[target.sequence]] <- indices[[target.sequence]][indices[[target.sequence]] != target.index]

        #increases the target index
        target.index <- target.index + 1

      } else {

        #target index is not repeated

        #adds the line to sequences.combined
        sequences.combined[j, ] <- sequences[which(sequences[ , grouping.column] == target.sequence & sequences$index == target.index), ]

        #removes the index from the given sequence
        indices[[target.sequence]] <- indices[[target.sequence]][indices[[target.sequence]] != target.index]

        #increases the target index
        target.index <- target.index + 1

      }

    } else {

      #target.index not in target sequence

      #switch sequence
      target.sequence <- sequence.names[sequence.names != target.sequence]

      #change target.index to the first index of the given sequence
      target.index <- indices[[target.sequence]][1]

      #adds the line to sequences.combined
      sequences.combined[j, ] <- sequences[which(sequences[ , grouping.column] == target.sequence & sequences$index == target.index), ]

      #removes the index from the given sequence
      indices[[target.sequence]] <- indices[[target.sequence]][indices[[target.sequence]] != target.index]

      #increases the target index
      target.index <- target.index + 1

    }

  }

  #getting index column
  index.column <- sequences.combined$index
  sequences$index <- NULL

  #getting the grouping column
  grouping.column.data <- sequences.combined[, grouping.column]
  sequences.combined[, grouping.column] <- NULL

  #adding it them the beginning
  sequences.combined <- data.frame(groups = grouping.column.data, index = index.column, sequences.combined)
  colnames(sequences.combined)[1] <- grouping.column
  colnames(sequences.combined)[2] <- "original.index"

  return(sequences.combined)

}
