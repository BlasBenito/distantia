#' Subset Sequences
#'
#' @description
#' Manipulates the dimension of a set of sequences.
#'
#' @param x (required, matrix) List of sequences generated by [prepare_sequences()]. Default: NULL
#' @param sequences (optional, character or numeric vector) Character vector of sequence names or numeric vector of sequence indices in `x`. If NULL, all sequences are kept. Default: NULL
#' @param variables (optional, character vector) Column names of the sequences in `x`. If NULL, all variables are returned. Default: NULL
#' @param time (optional, numeric vector) numeric vector with range of times to keep from the sequences in `x`. Rows of sequences in `x` outside such range are removed. If NULL, all rows in `x` are preserved. Default: NULL
#'
#' @return #' @return A named list of matrices.
#' @export
#' @autoglobal
#' @examples
subset_sequences <- function(
    x = NULL,
    sequences = NULL,
    variables = NULL,
    time = NULL
){

  #check x
  x <- check_args_x(x = x)

  # subset sequences ----
  if(!is.null(sequences)){

    ## sequences is a character ----
    if(is.character(sequences)){

      sequences <- match.arg(
        arg = sequences,
        choices = names(x),
        several.ok = TRUE
      ) |>
        unique()

    }

    # sequences is numeric ----
    if(is.numeric(sequences)){

      sequences <- sequences[
        sequences > 0 &
          sequences <= length(x)
        ] |>
        as.integer() |>
        unique()

    }

    x <- x[sequences]

  }

  # subset variables ----
  if(!is.null(variables)){

    #get all variable names
    all_variables <- lapply(
      X = x,
      FUN = function(z){
        attributes(z)$dimnames[[2]]
      }
    ) |>
      unlist() |>
      unique()

    variables <- match.arg(
      arg = variables,
      choices = all_variables,
      several.ok = TRUE
    )

    x <- lapply(
      X = x,
      FUN = function(i){
        i_attributes <- attributes(i)
        i <- i[, variables, drop = FALSE]
        attr(x = i, which = "time") <- i_attributes$time
        attr(x = i, which = "validated") <- i_attributes$validated
        attr(x = i, which = "sequence_name") <- i_attributes$sequence_name
        return(i)
      }
    )

  }

  # subset time ----
  if(!is.null(time)){

    if(length(time) < 2){
      stop("Argument 'time' must be a vector with at least two elements.")
    }

    x_names <- names(x)

    #get full range of time
    all_times <- lapply(
      X = x,
      FUN = function(z){
        attributes(z)$time
      }
    ) |>
      unlist() |>
      unique() |>
      as.numeric() |>
      sort()

    time <- as.numeric(time)

    all_times.range <- range(all_times, na.rm = TRUE)

    if(
      max(time) < min(all_times.range) ||
      min(time) > max(all_times.range)
    ){

      warning(
        "Range of argument 'time' (",
        paste(range(time), collapse = ", "),
        ") and range of times in 'x' (",
        paste(all_times.range, collapse = ", "),
        ") do nor overlap. Ignoring time subset."
      )

    } else {

      x <- lapply(
        X = x,
        FUN = function(i){

          i_attributes <- attributes(i)

          i_time <- i_attributes$time

          i_rows <- which(
            i_time >= min(time) &
              i_time <= max(time)
            )

          i_time <- i_time[i_rows]

          if(length(i_rows) == 0){
            return(NULL)
          }

          i <- i[i_rows, , drop = FALSE]

          attr(x = i, which = "time") <- i_time
          attr(x = i, which = "validated") <- i_attributes$validated
          attr(x = i, which = "sequence_name") <- i_attributes$sequence_name
          return(i)
        }
      )

      x <- Filter(Negate(is.null), x)

      x_removed <- setdiff(
        x = x_names,
        y = names(x)
      )

      if(length(x_removed) > 0){
        warning(
          "There following sequences do not overlap with 'time' and have been removed: ",
          paste0(x_removed, collapse = ", "),
          "."
        )

      }

    }

  }

  x

}
