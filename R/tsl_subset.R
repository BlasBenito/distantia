#' Subset Time Series List
#'
#' @description
#' Manipulates the dimension of a time series list.
#'
#' @param tsl (required, matrix) List of sequences generated by [tsl_initialize()]. Default: NULL
#' @param names (optional, character or numeric vector) Character vector of sequence names or numeric vector of sequence indices in `tsl`. If NULL, all sequences are kept. Default: NULL
#' @param colnames (optional, character vector) Column names of the sequences in `tsl`. If NULL, all variables are returned. Default: NULL
#' @param time (optional, numeric vector) numeric vector with range of times to keep from the sequences in `tsl`. Rows of sequences in `tsl` outside such range are removed. If NULL, all rows in `tsl` are preserved. Default: NULL
#'
#' @return #' @return A named list of matrices.
#' @export
#' @autoglobal
#' @examples
tsl_subset <- function(
    tsl = NULL,
    names = NULL,
    colnames = NULL,
    time = NULL
){

  tsl <- tsl_is_valid(
    tsl = tsl
  )

  # subset names ----
  if(!is.null(names)){

    ## names is a character ----
    if(is.character(names)){

      names <- match.arg(
        arg = names,
        choices = names(tsl),
        several.ok = TRUE
      ) |>
        unique()

    }

    # names is numeric ----
    if(is.numeric(names)){

      names <- names[
        names > 0 &
          names <= length(tsl)
        ] |>
        as.integer() |>
        unique()

    }

    tsl <- tsl[names]

  }

  # subset colnames ----
  if(!is.null(colnames)){

    #get all variable names
    all_colnames <- tsl_colnames(
      tsl = tsl,
      names = "all"
    ) |>
      unlist() |>
      unique()

    colnames <- match.arg(
      arg = colnames,
      choices = all_colnames,
      several.ok = TRUE
    )

    tsl <- lapply(
      X = tsl,
      FUN = function(i){
        i <- i[, colnames, drop = FALSE]
        dimnames(i) <- list(
          attributes(i)$index,
          colnames
          )
        return(i)
      }
    ) |>
      suppressWarnings()

  }

  # subset time ----
  if(!is.null(time)){

    if(length(time) < 2){
      stop("Argument 'time' must be a vector with at least two elements.")
    }

    tsl_names <- tsl_names(
      tsl = tsl
    )

    #get full range of time
    all_times <- lapply(
      X = tsl,
      FUN = function(z){
        attributes(z)$index
      }
    ) |>
      unlist() |>
      unique() |>
      as.numeric() |>
      sort()

    all_times.range <- range(all_times, na.rm = TRUE)

    if(
      max(time) < min(all_times.range) ||
      min(time) > max(all_times.range)
    ){

      warning(
        "Range of argument 'time' (",
        paste(range(time), collapse = ", "),
        ") and range of times in 'x' (",
        paste(all_times.range, collapse = ", "),
        ") do nor overlap. Ignoring time subset."
      )

    } else {

      tsl <- lapply(
        X = tsl,
        FUN = function(i){

          i <- stats::window(
            i,
            start = min(time),
            end = max(time)
          )

          return(i)

        }
      )

      tsl <- Filter(Negate(is.null), tsl)

      tsl_removed <- setdiff(
        x = tsl_names,
        y = tsl_names(
          tsl = tsl
        )
      )

      if(length(tsl_removed) > 0){
        warning(
          "There following time series do not overlap with 'time' and have been removed: ",
          paste0(tsl_removed, collapse = ", "),
          "."
        )

      }

    }

  }

  tsl <- tsl_names_set(
    tsl = tsl
  )

  tsl

}
