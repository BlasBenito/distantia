#' Subset Time Series List
#'
#' @description
#' Manipulates the dimension of a time series list.
#'
#' @param x (required, matrix) List of sequences generated by [tsl_prepare()]. Default: NULL
#' @param names (optional, character or numeric vector) Character vector of sequence names or numeric vector of sequence indices in `x`. If NULL, all sequences are kept. Default: NULL
#' @param colnames (optional, character vector) Column names of the sequences in `x`. If NULL, all variables are returned. Default: NULL
#' @param time (optional, numeric vector) numeric vector with range of times to keep from the sequences in `x`. Rows of sequences in `x` outside such range are removed. If NULL, all rows in `x` are preserved. Default: NULL
#'
#' @return #' @return A named list of matrices.
#' @export
#' @autoglobal
#' @examples
tsl_subset <- function(
    tsl = NULL,
    names = NULL,
    colnames = NULL,
    time = NULL
){

  #check x
  tsl <- check_args_x(
    x = tsl,
    arg_name = "tsl"
    )

  # subset names ----
  if(!is.null(names)){

    ## names is a character ----
    if(is.character(names)){

      names <- match.arg(
        arg = names,
        choices = names(tsl),
        several.ok = TRUE
      ) |>
        unique()

    }

    # names is numeric ----
    if(is.numeric(names)){

      names <- names[
        names > 0 &
          names <= length(tsl)
        ] |>
        as.integer() |>
        unique()

    }

    tsl <- tsl[names]

  }

  # subset colnames ----
  if(!is.null(colnames)){

    #get all variable names
    all_colnames <- lapply(
      X = tsl,
      FUN = function(z){
        attributes(z)$dimnames[[2]]
      }
    ) |>
      unlist() |>
      unique()

    colnames <- match.arg(
      arg = colnames,
      choices = all_colnames,
      several.ok = TRUE
    )

    x <- lapply(
      X = x,
      FUN = function(i){
        i.name <- attributes(i)$name
        i <- i[, colnames, drop = FALSE]
        colnames(i) <- colnames
        dimnames(i) <- list(
          attributes(i)$index,
          colnames
          )
        attr(x = i, which = "name") <- i.name
        return(i)
      }
    ) |>
      suppressWarnings()

  }

  # subset time ----
  if(!is.null(time)){

    if(length(time) < 2){
      stop("Argument 'time' must be a vector with at least two elements.")
    }

    x_names <- names(tsl)

    #get full range of time
    all_times <- lapply(
      X = tsl,
      FUN = function(z){
        attributes(z)$index
      }
    ) |>
      unlist() |>
      unique() |>
      as.numeric() |>
      sort()

    all_times.range <- range(all_times, na.rm = TRUE)

    if(
      max(time) < min(all_times.range) ||
      min(time) > max(all_times.range)
    ){

      warning(
        "Range of argument 'time' (",
        paste(range(time), collapse = ", "),
        ") and range of times in 'x' (",
        paste(all_times.range, collapse = ", "),
        ") do nor overlap. Ignoring time subset."
      )

    } else {

      x <- lapply(
        X = x,
        FUN = function(i){

          i.name <- attributes(i)$name

          i <- stats::window(
            i,
            start = min(time),
            end = max(time)
          )

          attr(x = i, which = "name") <- i.name

          return(i)

        }
      )

      x <- Filter(Negate(is.null), x)

      x_removed <- setdiff(
        x = x_names,
        y = names(x)
      )

      if(length(x_removed) > 0){
        warning(
          "There following time series do not overlap with 'time' and have been removed: ",
          paste0(x_removed, collapse = ", "),
          "."
        )

      }

    }

  }

  tsl

}
