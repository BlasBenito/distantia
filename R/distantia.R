#' Dissimilarity Between Time Series
#'
#' @description
#'
#' This function combines dynamic time warping, lock-step comparison, the psi dissimilarity score (Birks and Gordon 1985), and restricted permutation methods to assess the dissimilarity between pairs of time series.
#'
#' Dynamic time warping (DTW for short) is an optimization method aiming to minimize the distance between two time series. It ignores sampling time, but is restricted by sample order, which gives it flexibility to compare regular or irregular time series taken in different places (for example, phenological time series taken at different latitudes or elevations) or over different time spans (for example, time series taken over different years or past time periods). This method involves computing the distance matrix, cost matrix, and least cost path between all pairs of samples.
#'
#' Lock-step comparison involves assessing the multivariate distance between pairs of samples taken at the same time but belonging to separate regular time series. This method is an alternative to dynamic time warping when the goal requires assessing the synchronicity of the compared time series.
#'
#' The psi dissimilarity score normalizes the multivariate distance between the samples in two time series by the sum of distances between consecutive samples of each time series. This feature allows comparing psi dissimilarity scores computed for time series of different lengths. A psi score of zero indicates perfect similarity.
#'
#' Restricted permutation methods shuffle the cases of two time-series within blocks of a given size to generate a null distribution of psi dissimilarity scores. The true psi dissimilarity computed on the original data is compared with this null distribution to obtain a p-value that helps assess the strength of the dissimilarity score between both time-series. In essence, this p-value helps to find the threshold of the psi score that separates pairs of similar time series (because their similarity is robust to permutation) from pairs of dissimilar time-series.
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for very long time series.
#'
#' @param tsl (required, time series list) list of zoo time series. Default: NULL
#' @param distance (optional, character vector) name or abbreviation of the distance method. Valid values are in the columns "names" and "abbreviation" of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical vector). If TRUE, diagonals are included in the computation of the cost matrix. Default: FALSE.
#' @param weighted (optional, logical vector) If TRUE, diagonal is set to TRUE, and diagonal cost is weighted by a factor of 1.414214. Default: FALSE.
#' @param ignore_blocks (optional, logical vector). If TRUE, blocks of consecutive path coordinates are trimmed to avoid inflating the psi distance. Default: FALSE.
#' @param lock_step (optional, logical vector) If TRUE, time-series are compared row wise and no least-cost path is computed. Default: FALSE.
#' @param repetitions (optional, integer vector) number of permutations to compute the p-value. If 0, p-values are not computed. Otherwise, the minimum is 2. Default: 0
#' @param permutation (optional, character vector) permutation method, only relevant when `repetitions` is higher than zero. Valid values are listed below from higher to lower induced randomness:
#' \itemize{
#'   \item "free": unrestricted shuffling of rows and columns. Ignores block_size.
#'   \item "free_by_row": unrestricted shuffling of complete rows. Ignores block size.
#'   \item "restricted": restricted shuffling of rows and columns within blocks.
#'   \item "restricted_by_row": restricted shuffling of rows within blocks.
#' }
#' @param block_size (optional, integer) Row block sizes for the restricted permutation test. Only relevant when permutation methods are "restricted" or "restricted_by_row" and `repetitions` is higher than zero. A block of size `n` indicates that a row can only be permuted within a block of `n` adjacent rows. If NULL, defaults to the rounded one tenth of the shortest sequence in `tsl`. Default: NULL.
#' @param seed (optional, integer) initial random seed to use for replicability when computing p-values. Default: 1
#'
#' @return Data frame with the attribute `type` set to `distantia_df` and the following columns:
#' \itemize{
#'   \item `x`: name of the sequence `x`.
#'   \item `y`: name of the sequence `y`.
#'   \item `distance`: name of the distance metric.
#'   \item `diagonal`: value of the argument `diagonal`.
#'   \item `weighted`: value of the argument `weighted`.
#'   \item `ignore_blocks`: value of the argument `ignore_blocks`.
#'   \item `lock_step`: value of the argument `lock_step`.
#'   \item `repetitions` (only if `repetitions > 0`): value of the argument `repetitions`.
#'   \item `permutation` (only if `repetitions > 0`): name of the permutation method used to compute p-values.
#'   \item `seed` (only if `repetitions > 0`): random seed used to in the permutations.
#'   \item `null_mean` (only if `repetitions > 0`): mean of the null distribution of psi values computed from the permutaitons.
#'   \item `null_sd` (only if `repetitions > 0`): standard deviation of the null distribution of psi values.
#'   \item `p_value`  (only if `repetitions > 0`): proportion of scores smaller or equal than `psi` in the null distribution.
#'   \item `psi`: psi dissimilarity of the sequences `a` and `b`.
#' }
#' @export
#' @autoglobal
#' @examples
#' #parallelization
#' # future::plan(multisession, workers = 2)
#'
#' #progress bar
#' progressr::handlers(global = TRUE)
#'
distantia <- function(
    tsl = NULL,
    distance = "euclidean",
    diagonal = FALSE,
    weighted = FALSE,
    ignore_blocks = FALSE,
    lock_step = FALSE,
    repetitions = 0L,
    permutation = "restricted_by_row",
    block_size = NULL,
    seed = 1
){

  tsl <- tsl_remove_exclusive_cols(
    tsl = tsl
  )

  permutation <- match.arg(
    arg = permutation,
    choices = c(
      "restricted_by_row",
      "restricted",
      "free_by_row",
      "free"
    ),
    several.ok = TRUE
  )

  if(permutation %in% c("restricted_by_row", "restricted")){

    block_size <- utils_block_size(
      tsl = tsl,
      repetitions = repetitions,
      block_size = block_size
    )

  } else {

    block_size <- 0

  }

  #check input arguments
  args_test <- utils_check_distantia_args(
    tsl = tsl,
    distance = distance,
    diagonal = diagonal,
    weighted = weighted,
    ignore_blocks = ignore_blocks,
    lock_step = lock_step,
    repetitions = repetitions,
    block_size = block_size,
    seed = seed
  )

  #iterations data
  if(repetitions == 0){

    df <- utils_tsl_pairs(
      tsl = tsl,
      args_list = list(
        distance = distance,
        diagonal = diagonal,
        weighted = weighted,
        ignore_blocks = ignore_blocks,
        lock_step = lock_step
      )
    )

  } else {

    df <- utils_tsl_pairs(
      tsl = tsl,
      args_list = list(
        distance = distance,
        diagonal = diagonal,
        weighted = weighted,
        ignore_blocks = ignore_blocks,
        lock_step = lock_step,
        repetitions = repetitions,
        permutation = permutation,
        block_size = block_size,
        seed = seed
      )
    )

  }

  #add additional columns
  df$psi <- NA

  if(repetitions > 0){
    df$null_mean <- NA
    df$null_sd <- NA
    df$p_value <- NA
  }

  iterations <- seq_len(nrow(df))

  p <- progressr::progressor(along = iterations)

  `%iterator%` <- doFuture::`%dofuture%`

  df_distantia <- foreach::foreach(
    i = iterations,
    .combine = "rbind",
    .errorhandling = "pass",
    .options.future = list(seed = TRUE)
  ) %iterator% {

    p()

    df.i <- df[i, ]

    x <- tsl[[df.i$x]]
    y <- tsl[[df.i$y]]

    if(df$lock_step[i] == TRUE){

      df.i$psi <- psi_lock_step_cpp(
        x = x,
        y = y,
        distance = df.i$distance
      )

      if(repetitions > 0){

        psi_null <- null_psi_lock_step_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          repetitions = df.i$repetitions,
          permutation = df.i$permutation,
          block_size = df.i$block_size,
          seed = df.i$seed
        )

      }

    } else {

      df.i$psi <- psi_cpp(
        x = x,
        y = y,
        distance = df.i$distance,
        diagonal = df.i$diagonal,
        weighted = df.i$weighted,
        ignore_blocks = df.i$ignore_blocks
      )

      if(repetitions > 0){

        psi_null <- null_psi_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          diagonal = df.i$diagonal,
          weighted = df.i$weighted,
          ignore_blocks = df.i$ignore_blocks,
          repetitions = df.i$repetitions,
          permutation = df.i$permutation,
          block_size = df.i$block_size,
          seed = df.i$seed + i
        )

        df.i$p_value <- sum(psi_null <= df.i$psi) / repetitions
        df.i$null_mean <- mean(psi_null)
        df.i$null_sd <- sd(psi_null)

      }

    }

    return(df.i)

  } #end of iterations

  #add type
  attr(
    x = df_distantia,
    which = "type"
  ) <- "distantia_df"

  df_distantia

}
