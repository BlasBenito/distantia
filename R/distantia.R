#' Time Series Dissimilarity Analysis
#'
#' @description
#'
#' This function combines dynamic time warping and lock-step comparison with restricted permutation methods to assess dissimilarity between pairs time series or any other sort of data composed of events ordered across a relevant dimension.
#'
#' **Dynamic time warping** (DTW for short) minimizes the distance between time series. This method ignores sampling time and relies on sample order only. This feature allows it to address different scenarios when comparing regular or irregular time series: phenological time series captured at different latitudes or elevations; time series captured over different years or past time periods; time series lacking precise times; pairs of coordinates representing movement over time, such as migration flight paths.
#'
#' On the other hand, **lock-step comparison** involves assessing the pairwise distance between samples in time series captured at the same times. This method is an alternative to dynamic time warping when the goal requires assessing the synchronicity of the compared time series.
#'
#' The **psi dissimilarity score** normalizes the multivariate distance between time series samples by the sum of distances between consecutive samples of each time series. This feature allows comparing psi dissimilarity scores computed for time series of different lengths. A psi score of zero indicates perfect similarity.
#'
#' **Restricted permutation** rearranges time series samples to help generate a null distribution of dissimilarity scores. The observed dissimilarity score computed on the original data is compared with this null distribution to obtain a p-value that helps assess the strength of the dissimilarity score between two time-series. In essence, restricted permutation is useful to answer the question "how robust is the similarity between two time series?"
#'
#' Four different permutation methods are available:
#' \itemize{
#'   \item "restricted": Restricted shuffling of rows and columns within blocks of rows. This method separates the data into blocks of rows of given sizes, and rearranges the data within blocks with no restrictions.
#'   \item "restricted_by_row": Shuffling of complete rows within blocks of rows. This method assumes a dependency between data in the same row, and is useful for data representing percentages or proportions, or variables closely related with each other.
#'   \item "free": Unrestricted shuffling of rows and columns across the complete time series. This method assumes independence between data in separate columns. It generates unrealistic randomized scenarios and may lead to an overestimation of the robustness of dissimilarity scores.
#'   \item "free_by_row": Unrestricted shuffling of complete rows. This method is a useful alternative to "free" when there is a dependency between data in the same row, such as in data representing percentages or proportions.
#' }
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for large time series lists.
#'
#' @param tsl (required, time series list) list of zoo time series. Default: NULL
#' @param distance (optional, character vector) name or abbreviation of the distance method. Valid values are in the columns "names" and "abbreviation" of the dataset [distances]. Default: "euclidean".
#' @param diagonal (optional, logical vector). If TRUE, diagonals are included in the dynamic time warping computation. Default: TRUE
#' @param weighted (optional, logical vector) If TRUE, diagonal is set to TRUE, and diagonal cost is weighted by a factor of 1.414214. Default: TRUE
#' @param ignore_blocks (optional, logical vector). If TRUE, blocks of consecutive least cost path coordinates are trimmed to avoid inflating the psi dissimilarity Irrelevant if `diagonal = TRUE`. Default: FALSE.
#' @param lock_step (optional, logical vector) If TRUE, time-series captured at the same times are compared sample wise (with no dynamic time warping). Requires time series in argument `tsl` to be fully aligned, or it will return an error. Default: FALSE.
#' @param repetitions (optional, integer vector) number of permutations to compute the p-value. If 0, p-values are not computed. Otherwise, the minimum is 2. Default: 0
#' @param permutation (optional, character vector) permutation method, only relevant when `repetitions` is higher than zero. Valid values are: "restricted_by_row", "restricted", "free_by_row", and "free". Default: "restricted_by_row".
#' @param block_size (optional, integer) Size of the row blocks for the restricted permutation test. Only relevant when permutation methods are "restricted" or "restricted_by_row" and `repetitions` is higher than zero. A block of size `n` indicates that a row can only be permuted within a block of `n` adjacent rows. If NULL, defaults to the rounded one tenth of the shortest sequence in `tsl`. Default: NULL.
#' @param seed (optional, integer) initial random seed to use for replicability when computing p-values. Default: 1
#'
#' @return Data frame with the attribute `type` set to `distantia_df` and the following columns:
#' \itemize{
#'   \item `x`: name of the sequence `x`.
#'   \item `y`: name of the sequence `y`.
#'   \item `distance`: name of the distance metric.
#'   \item `diagonal`: value of the argument `diagonal`.
#'   \item `weighted`: value of the argument `weighted`.
#'   \item `ignore_blocks`: value of the argument `ignore_blocks`.
#'   \item `lock_step`: value of the argument `lock_step`.
#'   \item `repetitions` (only if `repetitions > 0`): value of the argument `repetitions`.
#'   \item `permutation` (only if `repetitions > 0`): name of the permutation method used to compute p-values.
#'   \item `seed` (only if `repetitions > 0`): random seed used to in the permutations.
#'   \item `null_mean` (only if `repetitions > 0`): mean of the null distribution of psi values computed from the permutaitons.
#'   \item `null_sd` (only if `repetitions > 0`): standard deviation of the null distribution of psi values.
#'   \item `p_value`  (only if `repetitions > 0`): proportion of scores smaller or equal than `psi` in the null distribution.
#'   \item `psi`: psi dissimilarity of the sequences `x` and `y`.
#' }
#' @export
#' @autoglobal
#' @examples
#' #parallelization (best option for large time series lists)
#' # future::plan(
#' #  multisession,
#' #  workers = 2
#' #)
#'
#' #progress bar
#' progressr::handlers(global = TRUE)
#'
distantia <- function(
    tsl = NULL,
    distance = "euclidean",
    diagonal = TRUE,
    weighted = TRUE,
    ignore_blocks = FALSE,
    lock_step = FALSE,
    repetitions = 0L,
    permutation = "restricted_by_row",
    block_size = NULL,
    seed = 1
){

  tsl <- tsl_remove_exclusive_cols(
    tsl = tsl
  )

  permutation <- match.arg(
    arg = permutation,
    choices = c(
      "restricted_by_row",
      "restricted",
      "free_by_row",
      "free"
    ),
    several.ok = TRUE
  )

  if(
    repetitions > 0 &&
    permutation %in% c(
      "restricted_by_row",
      "restricted"
      )
    ){

    block_size <- utils_block_size(
      tsl = tsl,
      block_size = block_size
    )

  } else {

    block_size <- 0

  }

  #check input arguments
  args_test <- utils_check_distantia_args(
    tsl = tsl,
    distance = distance,
    diagonal = diagonal,
    weighted = weighted,
    ignore_blocks = ignore_blocks,
    lock_step = lock_step,
    repetitions = repetitions,
    block_size = block_size,
    seed = seed
  )

  #iterations data
  if(repetitions == 0){

    df <- utils_tsl_pairs(
      tsl = tsl,
      args_list = list(
        distance = distance,
        diagonal = diagonal,
        weighted = weighted,
        ignore_blocks = ignore_blocks,
        lock_step = lock_step
      )
    )

  } else {

    df <- utils_tsl_pairs(
      tsl = tsl,
      args_list = list(
        distance = distance,
        diagonal = diagonal,
        weighted = weighted,
        ignore_blocks = ignore_blocks,
        lock_step = lock_step,
        repetitions = repetitions,
        permutation = permutation,
        block_size = block_size,
        seed = seed
      )
    )

  }

  #add additional columns
  df$psi <- NA

  if(repetitions > 0){
    df$null_mean <- NA
    df$null_sd <- NA
    df$p_value <- NA
  }

  iterations <- seq_len(nrow(df))

  p <- progressr::progressor(along = iterations)

  `%iterator%` <- doFuture::`%dofuture%`

  df_distantia <- foreach::foreach(
    i = iterations,
    .combine = "rbind",
    .errorhandling = "pass",
    .options.future = list(seed = TRUE)
  ) %iterator% {

    p()

    df.i <- df[i, ]

    x <- tsl[[df.i$x]]
    y <- tsl[[df.i$y]]

    if(df$lock_step[i] == TRUE){

      df.i$psi <- psi_lock_step_cpp(
        x = x,
        y = y,
        distance = df.i$distance
      )

      if(repetitions > 0){

        psi_null <- null_psi_lock_step_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          repetitions = df.i$repetitions,
          permutation = df.i$permutation,
          block_size = df.i$block_size,
          seed = df.i$seed
        )

        df.i$p_value <- sum(psi_null <= df.i$psi) / repetitions
        df.i$null_mean <- mean(psi_null)
        df.i$null_sd <- sd(psi_null)

      }

    } else {

      df.i$psi <- psi_cpp(
        x = x,
        y = y,
        distance = df.i$distance,
        diagonal = df.i$diagonal,
        weighted = df.i$weighted,
        ignore_blocks = df.i$ignore_blocks
      )

      if(repetitions > 0){

        psi_null <- null_psi_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          diagonal = df.i$diagonal,
          weighted = df.i$weighted,
          ignore_blocks = df.i$ignore_blocks,
          repetitions = df.i$repetitions,
          permutation = df.i$permutation,
          block_size = df.i$block_size,
          seed = df.i$seed + i
        )

        df.i$p_value <- sum(psi_null <= df.i$psi) / repetitions
        df.i$null_mean <- mean(psi_null)
        df.i$null_sd <- sd(psi_null)

      }

    }

    return(df.i)

  } #end of iterations

  #add type
  attr(
    x = df_distantia,
    which = "type"
  ) <- "distantia_df"

  df_distantia

}
