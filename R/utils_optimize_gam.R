#' Optimization of Univariate GAM Models
#'
#' @description
#'
#' Internal function used in [zoo_resample()]. It finds the `k` parameter of a univariate GAM formula `y ~ s(x, k = ?)` that minimizes the root mean squared error (rmse) between observations and predictions, and returns a model fitted with such `k`.
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for very long time series.
#'
#' @param x (required, numeric vector) predictor, usually a numeric version of a time vector.
#' @param y (required, numeric vector) response, usually a time series.
#'
#' @return GAM model.
#' @export
#' @autoglobal
#' @examples
#'
#' #zoo time series
#' ts <- zoo_simulate(
#'   cols = 1,
#'   rows = 30
#' )
#'
#' #response
#' y <- as.numeric(ts)
#' #y <- ts[, 1] #for multivariate time series
#'
#' #predictor
#' x <- as.numeric(zoo::index(ts))
#'
#' #parallelization
#' # future::plan(multisession)
#'
#' #progress bar
#' progressr::handlers(global = TRUE)
#'
#' #optimize k
#' m <- utils_optimize_gam(
#'   x = x,
#'   y = y
#' )
#'
#' summary(m)
#'
#' #plot observation
#' plot(
#'   x = zoo::index(ts),
#'   y = as.numeric(y),
#'   col = "forestgreen",
#'   type = "l",
#'   lwd = 2
#'   )
#'
#' #plot prediction
#' lines(
#'   x = zoo::index(ts),
#'   y = stats::predict(m, type = "response"),
#'   col = "red4"
#'   )
#'
utils_optimize_gam <- function(
    x = NULL,
    y = NULL
){

  # x <- zoo_simulate(
  #   cols = 1
  # )
  # y <- x[, 1]
  # x <- as.numeric(zoo::index(x))

  if(!is.numeric(x)){
    stop("Argument 'x' must be a numeric vector.")
  }

  if(!is.numeric(y)){
    stop("Argument 'y' must be a numeric vector.")
  }

  if(length(x) != length(y)){
    stop("Arguments 'x' and 'y' must be of the same length.")
  }

  names(x) <- NULL
  names(y) <- NULL

  model_df <- data.frame(
    x = x,
    y = y
  )

  k = seq(from = 3, to = nrow(model_df), by = 1)

  p <- progressr::progressor(
    along = seq_len(length(k))
    )

  `%iterator%` <- doFuture::`%dofuture%`

  rmse <- foreach::foreach(
    k = k,
    .combine = "c",
    .errorhandling = "pass",
    .options.future = list(seed = TRUE)
  ) %iterator% {

    p()

    gam.formula <- as.formula(
      object = paste0(
        "y ~ s(x, k = ",
        k,
        ")"
      )
    )

    gam.model <- tryCatch({
      mgcv::gam(
        formula = gam.formula,
        data = model_df
      )
    }, error = function(e) {
      NA
    }, warning = function(w) {
      NA
    })

    if(
      inherits(
        x = gam.model,
        what = "gam"
        ) == FALSE
      ){
      return(NA)
    }

    return(

      #correlation
      # cor(
      #   x = predict(gam.model),
      #   y = model_df$y,
      #   use = "pairwise.complete.obs"
      # )

      #rmse
      sqrt(mean((model_df$y - predict(gam.model))^2))


    )

  }

  r[!is.numeric(r)] <- NA

  best.k <- k[which.min(rmse)]

  gam.formula <- as.formula(
    object = paste0(
      "y ~ s(x, k = ",
      best.k,
      ")"
    )
  )

  gam.model <- tryCatch({
    mgcv::gam(
      formula = gam.formula,
      data = model_df
    )
  }, error = function(e) {
    NA
  }, warning = function(w) {
    NA
  })

  gam.model

}
