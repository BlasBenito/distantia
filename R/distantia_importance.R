#' Contribution of Individual Variables to Dissimilarity
#'
#' @description
#'
#' This function helps assess the contribution of individual variables to the dissimilarity between pairs of time series.
#'
#' Importance scores are based on three values:
#' \itemize{
#'   \item **psi**: overall dissimilarity when all variables are considered.
#'   \item **psi_only_with**: dissimilarity when only the given variable is considered.
#'   \item **psi_without**: dissimilarity when all other variables are considered.
#' }
#'
#' From these indicators, two importance scores are considered:
#'
#' \itemize{
#'   \item **psi_drop**: Computed as `((psi - psi_without) * 100)/psi` and interpreted as "increase in similarity when a variable is removed". Positive values indicate that the variable contributes to dissimilarity, while negative values indicate otherwise. This is the original importance score introduced with the first version of the package.
#'   \item **importance**: Computed as `((psi_only_with - psi_without) * 100)/psi` and interpreted as "relative dissimilarity induced by the variable". Positive values indicate that the variable contributes to dissimilarity, while negative values indicate otherwise. This is a new metric introduced with the version 2.0 of the package, and it is more informative than `psi_drop`.
#' }
#'
#' Additionally, these importance scores can be computed in two different ways defined by the argument `robust`. Please notice that this argument is irrelevant when `lock_step = TRUE`:
#' \itemize{
#'   \item `robust = TRUE` (default): Normalizes `psi_only_with` and `psi_without` from the least cost path of the full set of variables, making importance scores of separate variables fully comparable. This a novel version of the importance algorithm that yields more stable and comparable solutions.
#'   \item `robust = FALSE`: Normalizes `psi_only_with` and `psi_without` from the least cost path of the individual variables, which makes individual importance scores harder to compare. This option renders the "importance" column unreliable. However, the `psi_drop` score still remains as a useful metric of importance. This option can only be recommended when the goal is replicating or comparing with previous studies.
#' }
#'
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for very long time series.
#'
#' @param tsl (required, time series list) list of zoo time series. Default: NULL
#' @param distance (optional, character vector) name or abbreviation of the distance method. Valid values are in the columns "names" and "abbreviation" of the dataset `distances`. Default: "euclidean".
#' @param diagonal (optional, logical vector). If TRUE, diagonals are included in the computation of the cost matrix. Default: TRUE
#' @param weighted (optional, logical vector) If TRUE, diagonal is set to TRUE, and diagonal cost is weighted by a factor of 1.414214. Default: TRUE
#' @param ignore_blocks (optional, logical vector). If TRUE, blocks of consecutive path coordinates are trimmed to avoid inflating the psi distance. Ignored if `diagonal = TRUE`. Default: FALSE.
#' @param lock_step (optional, logical vector) If TRUE, time-series are compared row wise and no least-cost path optimization is performed. Requires time series in argument `tsl` to be fully aligned. Default: FALSE.
#' @param robust (required, logical vector). If TRUE (default), importance scores are computed using the least cost path of the complete time series as reference. Setting it to FALSE allows to replicate importance scores of the previous versions of this package. This option is irrelevant when `lock_step = TRUE`. Default: TRUE
#' @return Data frame with the following columns:
#' \itemize{
#'   \item `x`: name of the sequence `x`.
#'   \item `y`: name of the sequence `y`.
#'   \item `distance`: name of the distance metric.
#'   \item `diagonal`: value of the argument `diagonal`.
#'   \item `weighted`: value of the argument `weighted`.
#'   \item `ignore_blocks`: value of the argument `ignore_blocks`.
#'   \item `lock_step`: value of the argument `lock_step`.
#'   \item `robust`: value of the argument `robust`.
#'   \item `variable`: name of the individual variable.
#'   \item `psi`: overall psi score of `a` and `b`.
#'   \item `psi_only_with`: psi score of the variable.
#'   \item `psi_without`: psi score without the variable.
#'   \item `psi_difference`: difference between `psi_only_with` and `psi_without`.
#'   \item `psi_drop`: change in psi (as a percentage of the overall psi) when the variable is removed.
#'   \item `importance`: `psi_difference` as a precentage of `psi`. Only interpretable when `robust = TRUE`.
#' }
#' @export
#' @autoglobal
#' @examples
#' #three time series
#' #climate and ndvi in Fagus sylvatica stands in Spain, Germany, and Sweden
#' data("fagus_dynamics")
#'
#' tsl <- tsl_initialize(
#'   x = fagus_dynamics,
#'   id_column = "site",
#'   time_column = "date"
#' )
#'
#' if(interactive()){
#'   tsl_plot(
#'     tsl = tsl,
#'     guide_columns = 3
#'     )
#' }
#'
#' #parallelization setup (not worth it for this data size)
#' future::plan(
#'  future::multisession,
#'  workers = 2 #set to parallelly::availableWorkers() - 1
#' )
#'
#' #progress bar
#' progressr::handlers(global = TRUE)
#'
#' #dissimilarity analysis
#' tsl_dtw <- distantia(
#'   tsl = tsl
#' )
#' tsl_dtw[, c("x", "y", "psi")]
#'
#' #most similar cases are Germany and Sweden
#' #most different cases are Spain and Sweden
#'
#' #importance scores using dynamic time warping (lock_step = FALSE)
#' tsl_dtw_importance <- distantia_importance(
#'   tsl = tsl
#' )
#'
#' #focus on important columns
#' tsl_dtw_importance[, c("x", "y", "variable", "importance")]
#'
#' #in column "importance":
#' #  positive values: contribution to dissimilarity
#' #  negative values: contribution to similarity
#'
#' #variable making Germany and Sweden similar: rainfall
#' #variables making Spain and Sweden different: evi and temperature
#'
#' #WARNING: importance scores are very sensitive to scale!
#' #---------------------------------------------------------
#'
#' #scaling and centering tsl
#' tsl_scaled <- tsl_transform(
#'   tsl = tsl,
#'   f = f_scale
#' )
#'
#' #importance scores on scaled values
#' tsl_dtw_importance_scaled <- distantia_importance(
#'   tsl = tsl_scaled
#' )
#'
#' #very different results (scaling is the correct choice here)
#' tsl_dtw_importance_scaled[, c("x", "y", "variable", "importance")]
#'
#' #variable making Germany and Sweden similar: temperature and rainfall
#' #variables making Spain and Sweden different: evi and rainfall
#'
#' #importance computed with lock-step method
#' #NOTE: more sensitive to latitudinal or altitudinal differences
#' tsl_lock_step_importance_scaled <- distantia_importance(
#'   tsl = tsl_scaled,
#'   lock_step = TRUE
#' )
#'
#' tsl_lock_step_importance_scaled[, c("x", "y", "variable", "importance")]
#'
#' #variable making Germany and Sweden similar: rainfall and temperature
#' #variables making Spain and Sweden different: temperature and rainfall
#'
#' #disable parallelization
#' future::plan(
#'   future::sequential
#' )
distantia_importance <- function(
    tsl = NULL,
    distance = "euclidean",
    diagonal = TRUE,
    weighted = TRUE,
    ignore_blocks = FALSE,
    lock_step = FALSE,
    robust = TRUE
){

  #stop if tsl is univariate
  tsl_ncol <- sapply(
    X = tsl,
    FUN = ncol
  ) |>
    unique()

  if(1 %in% tsl_ncol){
    warning("There are univariate time series in 'tsl'. Importance scores only apply to multivariate time series. Please consider using distantia() instead.")
  }



  tsl <- tsl_remove_exclusive_cols(
    tsl = tsl
  )

  #check input arguments
  args_test <- utils_check_distantia_args(
    tsl = tsl,
    distance = distance,
    diagonal = diagonal,
    weighted = weighted,
    ignore_blocks = ignore_blocks,
    lock_step = lock_step,
    robust = robust
  )

  #tsl pairs
  df <- utils_tsl_pairs(
    tsl = tsl,
    args_list = list(
      distance = distance,
      diagonal = diagonal,
      weighted = weighted,
      ignore_blocks = ignore_blocks,
      lock_step = lock_step,
      robust = robust
    )
  )

  iterations <- seq_len(nrow(df))

  p <- progressr::progressor(along = iterations)

  #to silence loading messages
  `%iterator%` <- doFuture::`%dofuture%` |>
    suppressMessages()

  my_foreach <- foreach::foreach |>
    suppressMessages()

  df_importance <- my_foreach(
    i = iterations,
    .combine = "rbind",
    .options.future = list(seed = TRUE)
  ) %iterator% {

    p()

    df.i <- df[i, ]

    x <- tsl[[df.i$x]]
    y <- tsl[[df.i$y]]

    if(df.i$lock_step == TRUE){

      df.i$robust <- TRUE

      importance.i <- importance_lock_step_cpp(
        x = x,
        y = y,
        distance = df.i$distance
      )

    } else {

      if(df.i$robust == TRUE){

        importance.i <- importance_robust_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          diagonal = df.i$diagonal,
          weighted = df.i$weighted,
          ignore_blocks = df.i$ignore_blocks
        )

      } else {

        importance.i <- importance_cpp(
          x = x,
          y = y,
          distance = df.i$distance,
          diagonal = df.i$diagonal,
          weighted = df.i$weighted,
          ignore_blocks = df.i$ignore_blocks
        )

      }

    } #end of importance i

    #set NaN to zero for constant pairs of sequences
    importance.i[is.na(importance.i)] <- 0

    importance.i <- merge(
      x = df.i,
      y = importance.i
    )

    return(importance.i)

  } #end of loop

  df_importance <- df_importance[
    , c(
      "x",
      "y",
      "psi",
      "variable",
      "importance",
      "psi_drop",
      "psi_difference",
      "psi_without",
      "psi_only_with",
      "distance",
      "diagonal",
      "weighted",
      "ignore_blocks",
      "lock_step",
      "robust"
    )
  ]

  attr(
    x = df_importance,
    which = "type"
  ) <- "distantia_importance_df"

  df_importance

}
