#' Resamples Zoo Time Series to a New Time
#'
#' @description
#'
#' Given a zoo object and a time vector, this function uses Generalized Additive Models (GAM) to resample a zoo object to a new time. This operation is useful to align time series with different frequencies, or to transform irregular time series into regular.
#'
#' The new time vector must be of the same class as the time of the zoo object (either  numeric, Date, or POSIXct). This new time vector can be either created from scratch, or can be extracted from another zoo object with [zoo::index()].
#'
#' Each time series within the zoo object is modelled as a function of the original time of the zoo object with [mgcv::gam()], and then predicted to te new time.
#'
#' Please use this operation with care, as there are limits to the amount of resampling that can be done without distorting the data. The safest option is to keep the distance between new time points within the same magnitude of the distance between the old time points.
#'
#' This function supports progress bars generated by the `progressr` package. See examples.
#'
#' This function also accepts a parallelization setup via [future::plan()], but it might only be worth it for very long time series.
#'
#'
#' @param x (required, zoo object) Time series to resample Default: NULL
#' @param new_time (required, zoo object, or vector of the classes numeric, Date, or POSIXct) New time of the resampled zoo object. Must be of the same class of the time in `x`. If one of them is "numeric" and the other is not, an error is returned. If a zoo object is provided, its time is used as a template to resample `x`. If NULL, irregular time series are predicted into a regular version of their own time, and regular time series are returned as is. Default: NULL
#'
#' @return zoo object
#' @export
#' @autoglobal
#' @examples
#PREPARE DATA
#'
#' #simulate zoo object
#' x <- zoo_simulate(
#'   cols = 2,
#'   rows = 50
#' )
#'
#' #plot zoo object
#' zoo_plot(x)
#'
#' #check time
#' zoo::index(x)
#'
#' #new time to first day of each month
#' new_time <- seq.Date(
#'   from = as.Date("2010-01-01"),
#'   to = as.Date("2019-09-01"),
#'   by = "1 month"
#' )
#'
#' #RESAMPLING
#'
#' #parallelization setup (not needed for small data)
#' future::plan(multisession, workers = 3)
#'
#' #progress bar (not really needed for small data)
#' progressr::handlers(global = TRUE)
#'
#' #resampling
#' x_new <- zoo_resample(
#'   x = x,
#'   new_time = new_time
#' )
#'
#' #plot resampled zoo object
#' zoo_plot(x_new)
#'
#' #new time is set to the first day of each month
#' zoo::index(x_new)
zoo_resample <- function(
    x = NULL,
    new_time = NULL
){

  # x <- zoo_simulate()

  if(zoo::is.zoo(x) == FALSE){
    stop("Argument 'x' must be a zoo object.")
  }

  #extract time from x
  old_time <- zoo::index(x)

  #if no new_time
  if(is.null(new_time)){

    #create regular new_time from x
    new_time <- seq(
      from = min(old_time),
      to = max(old_time),
      length.out = length(old_time)
    )

  } else {

    #new_time is a zoo object
    if(zoo::is.zoo(new_time)){
      new_time <- zoo::index(new_time)
    }

    if(utils_is_time(x = new_time) == FALSE){
      new_time <- utils_as_time(x = new_time)
    }

  }

  #stop if only one of the classes is numeric
  if(
    sum(
      is.numeric(
        c(
          class(new_time),
          class(old_time)
          )
        )
      ) == 1
  ){
    stop("The time classes of 'x' and 'new_time' must either be 'numeric', or any of 'Date' and 'POSIXct'.")
  }

  #coerce class of x to new_time
  if(
    sum(
      "POSIXct" %in%  c(
        class(new_time),
        class(old_time)
        )
      ) == 1
  ){

    zoo::index(x) <- utils_coerce_time_class(
      x =  zoo::index(x),
      to = ifelse(
        test = "POSIXct" %in% class(new_time),
        yes = "POSIXct",
        no = class(new_time)
      )
    )

  }

  #coerce new_time within the bounds of old_time
  new_time <- new_time[
    new_time >= min(old_time) &
      new_time <= max(old_time)
    ]

  #compare old and new time intervals
  new_time_interval <- as.numeric(mean(diff(new_time)))
  old_time_interval <- as.numeric(mean(diff(new_time)))

  if(
    new_time_interval < (old_time_interval/10) ||
     new_time_interval > (old_time_interval*10)
     ){
    warning("The time intervals of 'new_time' and 'x' differ in one order of magnitude or more. The output time series might be highly distorted.")
  }

  #convert times to numeric
  new_time_numeric <- utils_coerce_time_class(
    x = new_time,
    to = "numeric"
  )

  old_time_numeric <- utils_coerce_time_class(
    x = old_time,
    to = "numeric"
  )

  iterations <- seq_len(ncol(x))

  #parallelization setup
  p <- progressr::progressor(
    along = iterations
  )

  `%iterator%` <- doFuture::`%dofuture%`

  x_new_time <- foreach::foreach(
    i = iterations,
    .combine = "cbind",
    .errorhandling = "pass",
    .options.future = list(seed = TRUE)
  ) %iterator% {

    p()

    x_old <- as.numeric(x[, i])

    #optimize gam
    gam.model <- utils_optimize_gam(
      x = old_time_numeric,
      y = x_old
    )

    #if model fails, return NA
    if(
      inherits(
        x = gam.model,
        what = "gam"
        ) == FALSE
    ){

      return(rep(x = NA, times = length(new_time)))

    }

    #predict gam
    x_new <- stats::predict(
      object = gam.model,
      newdata = data.frame(
        x = new_time_numeric
      )
    )

    # plot(old_time_numeric, x_old, type = "l", col = "red")
    # lines(new_time_numeric, x_new, type = "l")

    #set bounds
    x_new[x_new > max(x_old)] <- max(x_old)
    x_new[x_new < min(x_old)] <- min(x_old)

    return(x_new)

  }

  #rename columns
  colnames(x_new_time) <- colnames(x)

  #convert to zoo
  x_new_time <- zoo::zoo(
    x = x_new_time,
    order.by = new_time
  )


  #reset name
  if(!is.null(attributes(x)$name)){
    attr(
      x = x_new_time,
      which = "name"
    ) <- attributes(x)$name
  }

  x_new_time

}
