---
title: "Mapping Time Series Dissimilarity"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

#WORK IN PROGRESS

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  dpi = 150,
  fig.show = 'hold',
  fig.width = 5
)

options(scipen = 9999)
options(conflicts.policy = list(warn = FALSE))
```

## Summary

This article focuses on the spatial representation of dissimilarity scores.

TODO

## Setup

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = "hide"}
if (!requireNamespace("sf", quietly = TRUE)){
  install.packages("sf")
}
if (!requireNamespace("mapview", quietly = TRUE)){
  install.packages("mapview")
}
if (!requireNamespace("dplyr", quietly = TRUE)){
  install.packages("dplyr")
}
```

```{r, message=FALSE, warning=FALSE, results="hide"}
library(distantia, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(mapview, warn.conflicts = FALSE)
```


## Example Data

The examples below illustrate how to map dissimilarity scores using the datasets `covid_prevalence` and `covid_polygons` included with `distantia`. The dataset comprises time series of weekly Covid-19 prevalence in several California counties.

```{r, fig.height=4.5}
tsl <- distantia::tsl_initialize(
  x = distantia::covid_prevalence,
  name_column = "name",
  time_column = "time"
)

tsl_plot(
  tsl = tsl[1:10],
  columns = 2,
  guide = FALSE
)
```
The map below displays the relevant county polygons using `mapview()`.

```{r}
mapview::mapview(
  distantia::covid_counties,
  label = "name"
)
```


## Dissimilarity Analysis

In this section we prepare several datasets to use in the different mapping examples: a lock-step dissimilarity data frame (`df_psi`), dissimilarity stats per time series (`df_stats`), and a hierarchical clustering based on the dissimilarity scores (`df_cluster`).

```{r}
#lock-step dissimilarity analysis
df_psi <- distantia::distantia(
  tsl = tsl,
  lock_step = TRUE
)

#lock-step dissimilarity stats per time series
df_stats <- distantia::distantia_stats(
  df = df_psi
)

#hierarchical clustering of lock-step dissimilarity
df_cluster <- distantia::distantia_cluster_hclust(
  df = df_psi
)$df
```

## Dissimilarity Networks

The function `distantia_spatial_network()` transforms the result of `distantia()` to an sf data frame with edges connecting time series locations. The result can be interpreted as a *dissimilarity network*. 

```{r, message = FALSE, warning = FALSE}
sf_network <- distantia::distantia_spatial_network(
  df = df_psi,
  sf = distantia::covid_counties |> 
    dplyr::select(
      name, geometry
    )
)

dplyr::glimpse(sf_network)
```
The sf data frame has a field with the edge name, the columns `x`, `y`, and `psi` of the distantia data frame, a linestring geometry column, and the `length` column with the edge length.

This sf data frame can be mapped right away, but in this case there are too many pairs of counties to achieve a meaningful map

```{r, message = FALSE, warning = FALSE}
mapview::mapview(
  sf_network,
  layer.name = "Psi",
  label = "edge_name",
  zcol = "psi",
  color = distantia::utils_color_continuous_default()
)
```
The mess above can be solved by focusing on particular aspects of the data at hand. For example, below we subset `sf_network` to focus on the dissimilarity between San Francisco and its closer counties.

```{r, warning = FALSE}
#subset edges involving San Francisco
#with a maximum length of 250km
sf_network_subset <- sf_network |> 
  dplyr::filter(
    grepl(
      pattern = "San_Francisco",
      x = edge_name
    ),
    length < 250000
  )

#map country polygons and dissimilarity edges
mapview::mapview(
  covid_counties,
  col.regions = NA,
  color = "black",
  label = FALSE,
  legend = FALSE,
  map.type = "OpenStreetMap"
) +
  mapview::mapview(
    sf_network_subset,
    layer.name = "San Francisco - Psi",
    label = "edge_name",
    zcol = "psi",
    lwd = (1/sf_network_subset$psi)*10,
    color = distantia::utils_color_continuous_default()
  )
```
When the relationship to map is one-to-many, as above, it can also be mapped using polygons directly.

```{r}
sf_network_subset <- sf::st_dropsf_network_subset
```


## Mapping Dissimilarity Stats

Mapping the dissimilarity stats of each time series may help identify places that are somewhat *special* because they show a high dissimilarity with all others, or places that are *average* and have no distinctive features.

Merging the dissimilarity stats with the sf data frame containing the county polygons generates the spatial data required for the map.

```{r, warning = FALSE}
sf_stats <- merge(
  x = distantia::covid_counties,
  y = df_stats
)
```

The map below uses warm colors for places with a high dissimilarity with all others such as Humboldt county in the north west of the state, and cold colors for places with a higher dissimilarity with all others. 

```{r, warning = FALSE}
mapview::mapview(
  sf_stats |> 
    dplyr::select(
      mean,
      name
    ),
  layer.name = "Psi mean",
  zcol = "mean",
  label = "name",
  col.regions = distantia::utils_color_continuous_default(),
  alpha.regions = 1
)
```


## One To Many

```{r, eval = FALSE}
# county_name <- "San_Francisco"
# 
# df_psi_san_francisco <- df_psi |> 
#   dplyr::mutate(
#     name = ifelse(
#       test = x != county_name | y != county_name,
#       yes = x,
#       no = "other"
#     )
#   ) |> 
#   dplyr::filter(
#     name == county_name
#   ) |> 
#   dplyr::left_join(
#     y = distantia::covid_counties,
#     by = "name"
#   ) |> 
#   sf::st_sf()
# 
# dplyr::glimpse(df_psi_san_francisco)
```

```{r}
# mapview::mapview(
#   df_psi_san_francisco,
#   layer.name = paste0("Psi with ", county_name),
#   zcol = "psi",
#   col.regions = distantia::utils_color_continuous_default(),
#   alpha.regions = 1
# )
```


