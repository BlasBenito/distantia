---
title: "Mapping Time Series Dissimilarity"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

#WORK IN PROGRESS

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  dpi = 150,
  fig.show = 'hold',
  fig.width = 5
)

options(scipen = 9999)
options(conflicts.policy = list(warn = FALSE))
```

## Summary

Many time series happen at a given space, which can be represented either by a polygon, or by a pair of coordinates. The R package `distantia`, albeit focused on time series comparison, offers limited support to map time series dissimilarity.

This article illustrates this concept with several examples.

## Setup

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = "hide"}
if (!requireNamespace("pak", quietly = TRUE)) {
  install.packages("pak")
  pak::pkg_install(
    c(
    "dplyr",
    "mapview"
    )
  )
}
```

```{r, message=FALSE, warning=FALSE, results="hide"}
library(distantia)
library(dplyr)
library(mapview)
```




## Dissimilarity Stats

Mapping the dissimilarity stats of each time series  helps identify places that are somewhat *special* because they show a high dissimilarity with all others, or places that are *average* and have no distinctive features.

The example below illustrates this concept using the datasets `covid_prevalence` and `covid_polygons` included with `distantia`.

The dataset comprises time series of weekly Covid19 prevalence in several California counties.

```{r, fig.height=4.5}
tsl <- distantia::tsl_initialize(
  x = distantia::covid_prevalence,
  name_column = "name",
  time_column = "time"
)

tsl_plot(
  tsl = tsl[1:10],
  columns = 2,
  guide = FALSE
)
```

In this case, the data requires no scaling because we will be computing lock-step dissimilarity to highlight differences in synchronicity and magnitude between prevalence curves.

```{r}
df_psi <- distantia::distantia(
  tsl = tsl,
  lock_step = TRUE
)
```

The code below computes the dissimilarity stats of each time series against all others.

```{r}
df_stats <- distantia::distantia_stats(
  df = df_psi
)

head(df_stats)
```

Merging the dissimilarity stats with the sf data frame containing the county polygons generates the spatial data required for the map.

```{r, warning = FALSE}
sf_stats <- merge(
  x = distantia::covid_counties,
  y = df_stats
)
```

The map below uses warm colors for places with a high dissimilarity with all others such as Humboldt county in the north west of the state, and cold colors for places with a higher dissimilarity with all others. 

```{r, warning = FALSE}
mapview::mapview(
  sf_stats,
  layer.name = "Psi mean",
  zcol = "mean",
  col.regions = distantia::utils_color_continuous_default(),
  alpha.regions = 1
)
```


## One To Many

```{r, eval = FALSE}
county_name <- "San_Francisco"

df_psi_san_francisco <- df_psi |> 
  dplyr::mutate(
    name = ifelse(
      test = x != county_name | y != county_name,
      yes = x,
      no = "other"
    )
  ) |> 
  dplyr::filter(
    name == county_name
  ) |> 
  dplyr::left_join(
    y = distantia::covid_counties,
    by = "name"
  ) |> 
  sf::st_sf()

dplyr::glimpse(df_psi_san_francisco)
```
```{r}
mapview::mapview(
  df_psi_san_francisco,
  layer.name = paste0("Psi with ", county_name),
  zcol = "psi",
  col.regions = distantia::utils_color_continuous_default(),
  alpha.regions = 1
)
```


## Dissimilarity Networks

NOTE: this section uses the objects generated in the previous one.

The function `distantia_to_sf()` transforms the result of `distantia()` to a spatial file with edges connecting time series locations. The result can be interpreted as a *dissimilarity network*. 

```{r, message = FALSE, warning = FALSE}
sf_network <- distantia::distantia_to_sf(
  df = df_psi,
  xy = distantia::covid_counties |> 
    sf::st_centroid() |> 
    sf::st_sf()
)

mapview::mapview(
  sf_network,
  layer.name = "Psi",
  zcol = "psi",
  color = distantia::utils_color_continuous_default()
)
```


However, in this case there are too many combinations of counties to produce a meaningful map from the resulting sf data frame. This can be solved by focusing on particular aspects of the data at hand.

```{r, warning = FALSE}
sf_network_subset <- sf_network |> 
  dplyr::filter(
    x == "San_Francisco" | y == "San_Francisco"
  )

mapview::mapview(
  sf_network_subset,
  layer.name = "San Francisco - Psi",
  zcol = "psi",
  color = distantia::utils_color_continuous_default()
)
```
