---
title: "Mapping Time Series Dissimilarity"
output: 
  rmarkdown::html_document:
    toc: true
    toc_title: "Content"
    source: false
---

#WORK IN PROGRESS

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  eval = TRUE,
  collapse = TRUE,
  comment = "#>",
  dpi = 150,
  fig.show = 'hold',
  fig.width = 5
)

options(scipen = 9999)
options(conflicts.policy = list(warn = FALSE))
```

## Summary

This article focuses on the spatial representation of dissimilarity scores.

TODO

## Setup

```{r, echo = FALSE, message = FALSE, warning = FALSE, results = "hide"}
if (!requireNamespace("sf", quietly = TRUE)){
  install.packages("sf")
}
if (!requireNamespace("mapview", quietly = TRUE)){
  install.packages("mapview")
}
if (!requireNamespace("dplyr", quietly = TRUE)){
  install.packages("dplyr")
}
```

```{r, message=FALSE, warning=FALSE, results="hide"}
library(distantia, warn.conflicts = FALSE)
library(dplyr, warn.conflicts = FALSE)
library(mapview, warn.conflicts = FALSE)
```


## Example Data

The examples below illustrate how to map dissimilarity scores using the datasets `covid_prevalence` and `covid_polygons` included with `distantia`. The dataset comprises time series of weekly Covid-19 prevalence in several California counties.

```{r, fig.height=4.5}
tsl <- distantia::tsl_initialize(
  x = distantia::covid_prevalence,
  name_column = "name",
  time_column = "time"
)

tsl_plot(
  tsl = tsl[1:10],
  columns = 2,
  guide = FALSE
)
```
The map below displays the relevant county polygons using `mapview()`.

```{r}
mapview::mapview(
  distantia::covid_counties,
  label = "name"
)
```


## Dissimilarity Analysis

In this section we prepare several datasets to use in the different mapping examples: a lock-step dissimilarity data frame (`df_psi`), dissimilarity stats per time series (`df_stats`), and a hierarchical clustering based on the dissimilarity scores (`df_cluster`).

The lock-step dissimilarity analysis includes a permutation test p-values, which will be useful as criteria to select relevant mapping features.

```{r}
#parallelization setup
future::plan(
  future::multisession,
  workers = parallelly::availableCores() - 1
  )

#lock-step dissimilarity analysis
df_psi <- distantia::distantia(
  tsl = tsl,
  distance = "euclidean",
  lock_step = TRUE,
  repetitions = 1000,
  permutation = "restricted",
  block_size = 12 #weeks
)

#disable parallelization
future::plan(
  future::sequential
  )

#check resulting data frame
df_psi |> 
  dplyr::select(
    x,
    y,
    psi,
    p_value
  ) |> 
  dplyr::glimpse()
```
The code below aggregates *psi* scores in the data frame `df_psi` across time series.

```{r}
#lock-step dissimilarity stats per time series
df_stats <- distantia::distantia_stats(
  df = df_psi
)

df_stats |> 
  dplyr::select(
    name, mean
  ) |> 
  dplyr::glimpse()
```
Finally, we run a hierarchical clustering using the *psi* scores in `df_psi` as distance criteria.

```{r}
#hierarchical clustering of lock-step dissimilarity
df_cluster <- distantia::distantia_cluster_hclust(
  df = df_psi
)$df

dplyr::glimpse(df_cluster)
```

## Dissimilarity Networks

The function `distantia_spatial_network()` transforms the result of `distantia()` to an sf data frame with edges connecting time series locations. The result can be interpreted as a *dissimilarity network*. 

```{r, message = FALSE, warning = FALSE}
sf_network <- distantia::distantia_spatial_network(
  df = df_psi,
  sf = distantia::covid_counties |> 
    dplyr::select(
      name, geometry
    )
)

dplyr::glimpse(sf_network)
```
The sf data frame has a field with the edge name, the columns `x`, `y`, and `psi` of the distantia data frame, a linestring geometry column, and the `length` column with the edge length.

This sf data frame can be mapped right away, but in this case there are too many pairs of counties to achieve a meaningful map

```{r, message = FALSE, warning = FALSE}
mapview::mapview(
  sf_network,
  layer.name = "Psi",
  label = "edge_name",
  zcol = "psi",
  color = distantia::utils_color_continuous_default()
)
```

The mess above can be solved by focusing on particular aspects of the data at hand. For example, below we subset `sf_network` to focus on San Francisco and its most similar counties in terms of Covid19 prevalence.

```{r, warning = FALSE}
#subset edges involving San Francisco
#with a maximum length of 250km
sf_network_subset <- sf_network |> 
  dplyr::filter(
    grepl(
      pattern = "San_Francisco",
      x = edge_name
    ),
    p_value <= 0.05
  )

#map country polygons and dissimilarity edges
mapview::mapview(
  covid_counties,
  col.regions = NA,
  color = "black",
  label = "name",
  legend = FALSE,
  map.type = "OpenStreetMap"
) +
  mapview::mapview(
    sf_network_subset,
    layer.name = "San Francisco - Psi",
    label = "edge_name",
    zcol = "psi",
    lwd = (1/sf_network_subset$psi)*10,
    color = distantia::utils_color_continuous_default(n = nrow(sf_network_subset) - 1)
  )
```


## Mapping Dissimilarity Stats

Mapping the dissimilarity stats of each time series may help identify places that are somewhat *special* because they show a high dissimilarity with all others, or places that are *average* and have no distinctive features.

Merging the dissimilarity stats with the sf data frame containing the county polygons generates the spatial data required for the map.

```{r, warning = FALSE}
sf_stats <- merge(
  x = distantia::covid_counties,
  y = df_stats
)
```

The map below uses warm colors for places with a high dissimilarity with all others such as Humboldt county in the north west of the state, and cold colors for places with a higher dissimilarity with all others. 

```{r, warning = FALSE}
mapview::mapview(
  sf_stats |> 
    dplyr::select(
      mean,
      name
    ),
  layer.name = "Psi mean",
  zcol = "mean",
  label = "name",
  col.regions = distantia::utils_color_continuous_default(),
  alpha.regions = 1
)
```

